<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Mathias Payer">
<meta name="theme-color" content="#563d7c">
<title>HexHive</title>
<!-- Bootstrap core CSS -->
<link href="../css/bootstrap.min.css" rel="stylesheet"/>
<link href="../css/fontawesome.min.css" rel="stylesheet"/>
<link href="../css/academicons.min.css" rel="stylesheet"/>
</head>

<body>

<div class="container"> 
<nav class="navbar navbar-expand-md navbar-light bg-light static-top" style="background-color: #e3f2fd;">
  <a class="navbar-brand" href="../#"><img src="../img/hexhive.png" width="50px"/>&nbsp;<span style="color:#1d9f00;">Hex</span><span style="color:#000103;">Hive</span></a>
	<div class="navbar" id="navbar">
	<ul class="navbar-nav mr-auto">
		<li><a class="nav-link" href="../#people">People</a></li>
		<li class="nav-item"><a class="nav-link" href="../publications">Publications</a></li>
		<li class="nav-item"><a class="nav-link" href="../projects">Projects</a></li>
		<li class="nav-item"><a class="nav-link" href="../teaching/">Teaching</a></li>
		<li class="nav-item active"><a class="nav-link" href="#">Student Projects</a></li>
	</ul>
	</div>
	<img src="../img/epfl.png" class="ml-auto" width="100px"/>
</nav>
</div>

<main role="main" class="container">

<section id="epflprojects">
<div class="jumbotron">
<h4 id="hexhive-phd-msc-bsc-projects">HexHive PhD, MSc, BSc projects</h4>
<p>This is a list of possible open, unassigned BSc or MSc research projects in the HexHive group <b>for EPFL students</b>.</p>
<p>Check out our list of <a href="past_projects.html">completed projects</a> to get an idea of past projects.</p>
<p>The projects are designed to be adjustable and scalable according to the type of BSc, MSc, or short PhD research project depending on the depth of the evaluation and exploration. For all projects we expect an open mind, good coding skills (especially in C/C++), and the willingness to learn. Previous experience with compilers (LLVM), build systems, and reverse engineering helps but is not required.</p>
<p>If you are interested in any of these topics then apply through <a href="https://forms.gle/vtLPqWz6ZHHMApkSA">our application form</a>. All project applications have to go through this form and we will internally discuss all applications and then invite students for interviews. Apply early as spots are limited.</p>
<p>In the HexHive we welcome independent ideas from students as well, as long as they focus on the topics of system and software security, especially (but not exclusively) in sanitization of unsafe code, interactions between different components, mitigations, compiler-based security analyses, or fuzzing. So if you have an idea for your own project let us know and we can discuss! Reach out to the people most closest to your ideas and we'll let the ideas bubble up.</p>

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#android-acropalypse">Android acropalypse</a></li>
<li><a href="#arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</a></li>
<li><a href="#towards-deterministic-dynamic-analysis-of-inter-connected-services">Towards Deterministic Dynamic Analysis of Inter-connected Services</a></li>
<li><a href="#building-better-benchmarks">Building Better Benchmarks</a></li>
<li><a href="#seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</a></li>
<li><a href="#maintaining-magma-a-ground-truth-fuzzing-benchmark">Maintaining Magma: A Ground-Truth Fuzzing Benchmark</a></li>
<li><a href="#legacy-rebooted-a-comparative-study-of-unix-utilities-in-rust-and-c">Legacy Rebooted: A Comparative Study of Unix Utilities in Rust and C</a></li>
<li><a href="#how-deep-is-your-love">How deep is your love?</a></li>
<li><a href="#machine-learning-model-obfuscation">Machine Learning Model Obfuscation</a></li>
<li><a href="#beyond-the-sample-firmware-survey-of-embedded-system-security">Beyond the Sample Firmware: Survey of Embedded System Security</a></li>
<li><a href="#trust-across-the-skies-survey-of-all-altitude-aero-space-security">Trust Across the Skies: Survey of All-Altitude Aero-Space Security</a></li>
<li><a href="#other-projects">Other projects</a></li>
</ul>
</nav>
<h5 id="android-acropalypse">Android acropalypse</h5>
<ul>
<li>Point of contact: <a href="mailto:luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Suitable for: Msc Semester Project / Thesis</li>
<li>Keywords: Reverse Engineering, Static Analysis</li>
</ul>
<p>You might have heard about the recent security disaster that is <a href="https://www.da.vidbuchanan.co.uk/blog/exploiting-acropalypse.html">aCropalypse</a>. Well, it turns out that the reason behind this bug is Google silently updating some <a href="https://issuetracker.google.com/issues/180526528?pli=1">Android’s API for opening files</a> which causes files not to be truncated anymore when opening them.</p>
<p>This is pretty wild and we think that there might be many more applications of aCropalypse, not just cropped screenshots. This project is about writing tooling to automatically analyze Android apks and searching for potential alternative data leaks.</p>
<p>A candidate should be interested in:</p>
<ul>
<li>Android application reverse engineering</li>
<li>Static analysis tooling for Android apks</li>
</ul>
<h5 id="arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</h5>
<ul>
<li>Point of contact: <a href="luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Keywords: Retrowrite, binary rewriting, mobile reverse engineering</li>
</ul>
<p>A common feature of the Android ecosystem are proprietary binary blobs. Vendors may not update these and may not compile them with the latest exploit mitigations. A particular cause of concern are kernel modules given their privileged access.</p>
<p>Hexhive’s Retrowrite project is a state-of-the-art binary rewriting tool that can retrofit mitigations to legacy binaries without the need for source code. This currently works on ARM64 and x86-64 platforms, and x86-64 in kernel mode. The goal of this project would be to target ARM64 kernel modules, with the ability to add for example kASAN. We would aim to:</p>
<ul>
<li>Identify kernel modules of particular interest, including open source modules to act as ground truth.</li>
<li>Produce a framework to evaluate the effectiveness of binary rewriting these modules by exercising their functionality, using fuzzing where appropriate.</li>
<li>Modify Retrowrite to support ARM64 kernel modules.</li>
<li>Evaluate the implementation against ground truth targets and against targets of interest. Evaluate the cost of instrumentation passes.</li>
</ul>
<p>Students should have a basic understanding of how Linux kernel modules are built and loaded, and a good grasp of Linux internals. Ambitious students may also have Android Internals knowledge and be interested in testing their work on Android hardware.</p>
<h5 id="towards-deterministic-dynamic-analysis-of-inter-connected-services">Towards Deterministic Dynamic Analysis of Inter-connected Services</h5>
<ul>
<li>Point of contact: <a href="mailto:florian.hofhammer@epfl.ch">Florian Hofhammer</a></li>
<li>Suitable for: MSc thesis</li>
<li>Keywords: Emulation, dynamic binary instrumentation, re-hosting, firmware</li>
</ul>
<p>Previous re-hosting work has mainly focused on bringing a single firmware image up in a virtualized environment for various dynamic analysis use cases. This approach is certainly valid for use cases such as fuzzing, where we want to simply throw as many inputs at a target’s exposed interfaces as possible, not caring too much about how realistic those inputs are.</p>
<p>Take as an example a car’s engine control unit (ECU): if we want to find bugs via fuzzing, we “simply” (a pretty bold claim in the re-hosting world :)) execute it over and over again with randomized inputs to cover as much of its code as possible. The input interfaces might include temperature sensors inside the car’s engine. Assuming the firmware crashes when handling a reported temperature of -999°C, such a crash is certainly an interesting finding but far off from reality and therefore potentially a false positive bug (I’d like to actually see a combustion engine running at negative temperatures, especially at temps below 0K before I consider this a true positive :)).</p>
<p>To weed out false positives in fuzzing or also for other dynamic analysis use cases (could be as simple as quick debugging iteration during firmware development), we would like to re-host firmware in a more realistic environment. One approach for this aim would be to constrain the input spaces to realistic values. Another approach (and the one we want to target in this project) is to model a full system instead of only single components. In the above example, this could mean re-hosting both the ECU firmware and potential sensor endpoints so that the sensor endpoints would provide the ECU with more realistic data based on their internal, potentially opaque calculations. However, we need to ensure deterministic execution of such a composed system to, e.g., reliably reproduce bugs. This project therefore has two goals:</p>
<ol type="1">
<li>Build a multi-system dynamic analysis framework</li>
<li>Design the framework in such a way that execution is deterministic</li>
</ol>
<p>A student working on this project should have:</p>
<ul>
<li>Experience with emulation via tools such as <a href="https://www.qemu.org/">QEMU</a>, <a href="https://panda.re/">PANDA</a>, <a href="https://www.unicorn-engine.org/">Unicorn</a>, or similar</li>
<li>Strong systems programming skills (at least C, potentially also other languages such as Rust or Zig)</li>
<li>Reverse engineering experience</li>
<li>Experience with/the willingness to learn about embedded systems (both microcontroller and application processor-based (e.g., Arm Cortex-M and Cortex-A)</li>
</ul>
<h5 id="building-better-benchmarks">Building Better Benchmarks</h5>
<ul>
<li>Point of contact: <a href="mailto:florian.hofhammer@epfl.ch">Florian Hofhammer</a></li>
<li>Suitable for: MSc semester project, potentially also BSc semester project</li>
<li>Keywords: benchmarking, evaluation, CI/CD, devops</li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/Replication_crisis">replication crisis</a> in academia in general and CS in particular has caused recent developments such as conferences requiring to submit paper artifacts and awarding badges for reproduced results.</p>
<p>While this is an important step forward in making research results more <em>reproducible</em>, the results are still not necessarily <em>comparable</em>. Different papers on the same subject may use different benchmarks to drive their point home, or use the same benchmarks but report different metrics obtained from those benchmarks (e.g., one paper focuses on compute overhead whereas another paper focuses on memory overhead).</p>
<p>We are aiming to create a standardized set of benchmarks and metrics to evaluate papers’ artifacts and compare their results fairly. In this project, you will integrate existing research artifacts into an evaluation pipeline and extend this pipeline with additional benchmarks. You will then process the benchmark results into a standardized set of metrics.</p>
<p>This project requires:</p>
<ul>
<li>A good understanding of build systems and how to build and run systems software (GNU make, cmake,…)</li>
<li>Experience with containerization tools such as Docker or Podman</li>
<li>Scripting/data processing experience (Python, Bash, or your favorite other language if applicable)</li>
<li>Experience with CI/CD pipelines for automated benchmark running is a plus</li>
</ul>
<h5 id="seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</h5>
<ul>
<li>Point of contact: <a href="luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Suitable for: MSc thesis</li>
<li>Keywords: kernel security, data race protection, security policy</li>
</ul>
<p>System call filtering is a crucial part of protection policies ubiquitous in cloud, desktop and mobile environments (Android, Docker, etc.). The existing SECCOMP filter system is unable to inspect arguments passed by reference since the user can modify the values in memory, resulting in a TOCTTOU exploit.</p>
<p>Midas is a novel mitigation for TOCTTOU bugs in the kernel, exploiting the user memory access API to provide double fetch protection. In this project, you will implement and evaluate SECCOMP filtering for system call arguments passed by reference, leveraging Midas to protect the kernel from the double fetch introduced in the process.</p>
<ul>
<li>This project requires:
<ul>
<li>Expert experience in C development</li>
<li>Experience with standard C/GNU build, development and debug tools (gdb, Makefiles)</li>
<li>Understanding of OS principles</li>
<li>Basic experience of OS coding/course project</li>
<li>Understanding of the x86 architecture and assembly coding/debugging</li>
</ul></li>
</ul>
<h5 id="maintaining-magma-a-ground-truth-fuzzing-benchmark">Maintaining Magma: A Ground-Truth Fuzzing Benchmark</h5>
<ul>
<li>Point of contact: <a href="mailto:qiang.liu@epfl.ch">Qiang Liu</a></li>
<li>Suitable for: BSc semester Project, potentially MSc semester project</li>
<li>Keywords: Fuzzing, Evaluation, Benchmark</li>
</ul>
<p><a href="https://hexhive.epfl.ch/magma/">Magma</a> is a fuzzer evaluation framework that enables accurate performance measurements by leveraging ground-truth information on bugs in real software. Magma includes a library of real targets (e.g. libpng, libtiff, openssl, etc…) with real bugs that have been re-introduced into those targets based on previous bug reports and fix commits. By reverse-engineering the commit which fixed a certain bug, we can identify what the root cause of the bug was, reintroduce it, and add a check (a canary) to determine when that bug is triggered, based on program state information available at runtime (i.e., variable values).</p>
<p>As fuzzers are tuned and improved on a regular basis, the benchmark upon which they’re evaluated must equally be upgraded, to keep up with the progress and avoid becoming out-dated. To achieve this, new targets and bugs must be added frequently, and old targets and bugs must be checked again for relevance, in case some bugs become unreachable/untrigerrable, or in case the target’s source code has changed enough to disallow the reintroduction of some bug without reintroducing old code functionality.</p>
<p>For this project, you are expected to:</p>
<ul>
<li>Finish collecting the Proof-of-Concepts to trigger the injected bugs</li>
<li>Potentially automate valid input construction</li>
</ul>
<h5 id="legacy-rebooted-a-comparative-study-of-unix-utilities-in-rust-and-c">Legacy Rebooted: A Comparative Study of Unix Utilities in Rust and C</h5>
<ul>
<li>Point of contact: <a href="mailto:rafaila.galanopoulou@epfl.ch">Rafaila Galanopoulou</a></li>
<li>Suitable for: MSc semester project or thesis, potentially also BSc semester project</li>
<li>Keywords: systems security, language safety, vulnerability analysis</li>
</ul>
<p>Developed for over 30 years, <a href="https://en.wikipedia.org/wiki/History_of_Linux">Linux</a> has already become the computing foundation for today’s digital world; from gigantic, complex mainframes (e.g., supercomputers) to cheap, wimpy embedded devices (e.g., IoTs), countless applications are built on top of it. <a href="https://doc.rust-lang.org/book/">Rust</a> is a statically and strongly-typed language. In short, its safety model regulates the accesses to memory locations: at one given time, only one variable may write to a memory location but many may read from it.</p>
<p>We focus on a selection of widely used Unix utilities such as <code>sed</code>, <code>grep</code>, <code>tar</code>, <code>find</code>, <code>netcat</code>, and <code>sort</code>. For each utility, we will either port an existing Rust-based clone or develop a minimal functional reimplementation in Rust using automated translation tools. The original GNU or BSD implementations written in C will serve as the baseline for comparison.</p>
<p>For this project, the objectives are to:</p>
<ul>
<li>Identify and compare the types and historical evolution of vulnerabilities in C and Rust implementations.</li>
<li>Analyze how Rust’s safety guarantees mitigate specific classes of bugs.</li>
<li>Evaluate the practicality and trade-offs of rewriting or porting Unix utilities from C to Rust.</li>
<li>Investigate the impact of feature set size and code complexity on the overall security surface.</li>
</ul>
<h5 id="how-deep-is-your-love">How deep is your love?</h5>
<ul>
<li>Point of contact: <a href="mailto:rafaila.galanopoulou@epfl.ch">Rafaila Galanopoulou</a></li>
<li>Suitable for: MSc semester project or thesis, potentially also BSc semester project</li>
<li>Keywords: cross-language analysis, dependency mapping, software supply chain security</li>
</ul>
<p>Modern software ecosystems increasingly rely on cross-language architectures. These dependencies are often deeply nested and opaque, making it difficult to fully understand control flow, data flow, and potential risk boundaries. Using multiple programming languages and libraries has other challenges, i.e., increasing the complexity and support issues. As a result, developers need to track versions, bugs, and compatibility with multiple compilers and runtimes rather than a single set.</p>
<p>We focus on a curated set of 10–50 real-world PyPI software projects, selected based on factors such as popularity and maturity. For each project, we will create the call graphs using either static analysis or dynamic tracing. These graphs aim to capture the complete invocation paths, including transitions between high-level code and native components written in other programming languages.</p>
<p>For this project, the objectives are to:</p>
<ul>
<li>Select and analyze a diverse set of Python projects using cross-language components.</li>
<li>Build static or dynamic call graphs that trace API and function invocations across language boundaries.</li>
<li>Annotate and classify unresolved edges, particularly those crossing into foreign code, to identify fragile or opaque integration points.</li>
<li>Visualize and quantify key metrics: total functions, call graph coverage,language breakdown, and which functionalities are implemented in each language.</li>
</ul>
<h5 id="machine-learning-model-obfuscation">Machine Learning Model Obfuscation</h5>
<ul>
<li>Point of contact: <a href="mailto:qiang.liu@epfl.ch">Qiang Liu</a></li>
<li>Suitable for: BSc semester project, potentially BSc thesis, MSc semester project or thesis</li>
<li>Keywords: AI compiler, ML models, ML binaries, obfuscation</li>
</ul>
<p>AI compilers transform scripts that describe machine learning models (ML models) into hardware-executable binaries (ML binaries). Examples include PyTorch Glow, TensorFlow XLA, Apache TVM, and NVIDIA cuDNN. The compilation process typically lowers models through multiple stages: first into high-level intermediate representations (IRs), then into low-level IRs, and finally into machine code [1]. High-level IRs usually take the form of computation graphs that represent the structure of the ML model. They are generally hardware-agnostic, meaning they don’t assume a specific execution platform. Low-level IRs, on the other hand, are generally framework-agnostic, meaning they can be generated from different front-end frameworks but are more closely tied to specific hardware backends. In some cases, ML models can also be compiled to WebAssembly (Wasm), which provides relatively fast performance and is portable across different platforms.</p>
<p>While ML models rely on massive amounts of data and computing resources, they are extremely valuable assets, and once deployed, their confidentiality must be preserved. However, this guarantee can be undermined through techniques such as model de-compilation [2] or side-channel information leakage [3].</p>
<p>Our goal is to explore obfuscation techniques for ML models, and more broadly, to develop general capabilities for security optimization of ML models by extending and modifying compiler infrastructures. Since this project is in an early stage, the objectives are to:</p>
<ul>
<li>Compile diverse ML models with different compilers to obtain the corresponding binaries across multiple backends</li>
<li>Analyze the execution of these binaries on CPU/GPU, focusing on their runtime behavior, memory access patterns, and data sharing mechanisms</li>
<li>Study existing machine learning–based de-compilation techniques and explore ways to break their assumptions or patterns by modifying compilers such that the generated binaries are resistant to decompilation</li>
</ul>
<p>Recommended readings:</p>
<p>[1] <a href="https://huyenchip.com/2021/09/07/a-friendly-introduction-to-machine-learning-compilers-and-optimizers.html">A friendly introduction to machine learning compilers and optimizers</a><br />
[2] <a href="https://www.usenix.org/system/files/conference/usenixsecurity25/sec24winter-prepub-338-wu-ruoyu.pdf">NEUROSCOPE: Reverse Engineering Deep Neural Network on Edge Devices using Dynamic Analysis</a><br />
[3] <a href="https://gpuhammer.com/">GPUHammer: Rowhammer Attacks on GPU Memories are Practical</a></p>
<h5 id="beyond-the-sample-firmware-survey-of-embedded-system-security">Beyond the Sample Firmware: Survey of Embedded System Security</h5>
<ul>
<li>Point of contact: <a href="mailto:qiang.liu@epfl.ch">Qiang Liu</a></li>
<li>Suitable for: BSc semester project, potentially BSc thesis, MSc semester project, or thesis</li>
<li>Keywords: Embedded system security, Hardening and attacks, Embedded inference</li>
</ul>
<p>Embedded systems power critical applications ranging from satellites and public transport to agricultural machinery, smart locks, routers, and cameras. Their security cannot be captured by sample firmware alone, as real-world threats span multiple layers. At the hardware level, attacks such as voltage glitching challenge integrity measurement and device resilience, while hardening techniques aim to close these gaps. At the hardware–software boundary, co-designed mitigations like MPUs and hypervisors play a key role in isolation and key management, yet remain targets of sophisticated attacks. At the software layer, authentication protocols and cryptographic keys are frequently exposed, undermining device trustworthiness. This survey provides a holistic view of these challenges and defenses, while also considering the computational capacity of embedded platforms and their growing role in enabling embedded inference at the edge.</p>
<p>The objectives are to:</p>
<ul>
<li>Compile a representative list of critical embedded devices and their firmware</li>
<li>Survey existing mitigations at the hardware, hardware–software co-design, and software levels, along with corresponding attack techniques</li>
<li>Assess the computational capabilities of embedded systems and examine the feasibility and challenges of deploying machine learning inference on these platforms</li>
</ul>
<p>Recommended readings:</p>
<p>[1] <a href="https://dl.acm.org/doi/pdf/10.1145/3433210.3453093">SoK: Enabling Security Analyses of Embedded Systems via Rehosting</a></p>
<h5 id="trust-across-the-skies-survey-of-all-altitude-aero-space-security">Trust Across the Skies: Survey of All-Altitude Aero-Space Security</h5>
<ul>
<li>Point of contact: <a href="mailto:qiang.liu@epfl.ch">Qiang Liu</a></li>
<li>Suitable for: BSc semester project, potentially BSc thesis, MSc semester project, or thesis</li>
<li>Keywords: Embedded system security, Hardening and attacks, Embedded inference</li>
</ul>
<p>All-altitude aero-space security spans diverse targets—including satellites, aircraft, drones, base stations, and supporting cloud infrastructures—but the most critical challenge lies in securing the integrated cloud–base station–aircraft–satellite networks. These multi-layered systems enable global communication, navigation, and control, yet also introduce cascading vulnerabilities. An adversary who compromises a single layer, such as a base station or cloud service, may propagate attacks upward to aircraft or satellites, or downward to end devices, threatening safety and mission continuity. Known attack vectors include GPS spoofing, signal jamming, avionics intrusion, and exploitation of weak authentication and key management in cross-domain links. Mitigations require coordinated defenses: trusted execution in aircraft and satellites, integrity verification at base stations, and secure orchestration in the cloud. Building resilience in these interconnected networks remains a central challenge, demanding end-to-end designs that unify hardware, protocol, and system-level defenses across altitudes.</p>
<p>The objectives are to:</p>
<ul>
<li>Compile a representative list of aero-space targets</li>
<li>Survey existing mitigations and attacks</li>
</ul>
<p>Recommended readings:</p>
<p>[1] <a href="https://media.ccc.de/v/38c3-hacking-yourself-a-satellite-recovering-beesat-1">Hacking yourself a satellite - recovering BEESAT-1</a></p>
<h5 id="other-projects">Other projects</h5>
<p>Several other projects are possible in the areas of software and system security. We are open to discussing possible projects around the development of security benchmarks, using machine learning to detect vulnerabilities, secure memory allocation, sanitizer-based coverage tracking, and others.</p>


</div>
</section>

</main>
</body>
</html>
