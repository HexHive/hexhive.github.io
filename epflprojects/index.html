<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Mathias Payer">
<meta name="theme-color" content="#563d7c">
<title>HexHive</title>
<!-- Bootstrap core CSS -->
<link href="../css/bootstrap.min.css" rel="stylesheet"/>
<link href="../css/fontawesome.min.css" rel="stylesheet"/>
<link href="../css/academicons.min.css" rel="stylesheet"/>
</head>

<body>

<div class="container"> 
<nav class="navbar navbar-expand-md navbar-light bg-light static-top" style="background-color: #e3f2fd;">
  <a class="navbar-brand" href="../#"><img src="../img/hexhive.png" width="50px"/>&nbsp;<span style="color:#1d9f00;">Hex</span><span style="color:#000103;">Hive</span></a>
	<div class="navbar" id="navbar">
	<ul class="navbar-nav mr-auto">
		<li><a class="nav-link" href="../#people">People</a></li>
		<li class="nav-item"><a class="nav-link" href="../publications">Publications</a></li>
		<li class="nav-item"><a class="nav-link" href="../projects">Projects</a></li>
		<li class="nav-item"><a class="nav-link" href="../teaching/">Teaching</a></li>
		<li class="nav-item active"><a class="nav-link" href="#">Student Projects</a></li>
	</ul>
	</div>
	<img src="../img/epfl.png" class="ml-auto" width="100px"/>
</nav>
</div>

<main role="main" class="container">

<section id="epflprojects">
<div class="jumbotron">
<h4 id="hexhive-phd-msc-bsc-projects">HexHive PhD, MSc, BSc projects</h4>
<p>This is a list of possible open, unassigned BSc or MSc research projects in the HexHive group <b>for EPFL students</b>.</p>
<p>Check out our list of <a href="past_projects.html">completed projects</a> to get an idea of past projects.</p>
<p>The projects are designed to be adjustable and scalable according to the type of BSc, MSc, or short PhD research project depending on the depth of the evaluation and exploration. For all projects we expect an open mind, good coding skills (especially in C/C++), and the willingness to learn. Previous experience with compilers (LLVM), build systems, and reverse engineering helps but is not required.</p>
<p>If you are interested in any of these topics then apply through <a href="https://forms.gle/vtLPqWz6ZHHMApkSA">our application form</a>. All project applications have to go through this form and we will internally discuss all applications and then invite students for interviews. Apply early as spots are limited.</p>
<p>In the HexHive we welcome independent ideas from students as well, as long as they focus on the topics of system and software security, especially (but not exclusively) in sanitization of unsafe code, interactions between different components, mitigations, compiler-based security analyses, or fuzzing. So if you have an idea for your own project let us know and we can discuss! Reach out to the people most closest to your ideas and we'll let the ideas bubble up.</p>

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#android-acropalypse">Android acropalypse</a></li>
<li><a href="#arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</a></li>
<li><a href="#seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</a></li>
<li><a href="#agentic-magma-a-ground-truth-fuzzing-benchmark">Agentic Magma: A Ground-Truth Fuzzing Benchmark</a></li>
<li><a href="#legacy-rebooted-a-comparative-study-of-unix-utilities-in-rust-and-c">Legacy Rebooted: A Comparative Study of Unix Utilities in Rust and C</a></li>
<li><a href="#how-deep-is-your-love">How deep is your love?</a></li>
<li><a href="#synthesizing-peripheral-models-from-mcu-manuals-with-llms">Synthesizing Peripheral Models from MCU Manuals with LLMs</a></li>
<li><a href="#other-projects">Other projects</a></li>
</ul>
</nav>
<h5 id="android-acropalypse">Android acropalypse</h5>
<ul>
<li>Point of contact: <a href="mailto:luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Suitable for: Msc Semester Project / Thesis</li>
<li>Keywords: Reverse Engineering, Static Analysis</li>
</ul>
<p>You might have heard about the recent security disaster that is <a href="https://www.da.vidbuchanan.co.uk/blog/exploiting-acropalypse.html">aCropalypse</a>. Well, it turns out that the reason behind this bug is Google silently updating some <a href="https://issuetracker.google.com/issues/180526528?pli=1">Android’s API for opening files</a> which causes files not to be truncated anymore when opening them.</p>
<p>This is pretty wild and we think that there might be many more applications of aCropalypse, not just cropped screenshots. This project is about writing tooling to automatically analyze Android apks and searching for potential alternative data leaks.</p>
<p>A candidate should be interested in:</p>
<ul>
<li>Android application reverse engineering</li>
<li>Static analysis tooling for Android apks</li>
</ul>
<h5 id="arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</h5>
<ul>
<li>Point of contact: <a href="luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Keywords: Retrowrite, binary rewriting, mobile reverse engineering</li>
</ul>
<p>A common feature of the Android ecosystem are proprietary binary blobs. Vendors may not update these and may not compile them with the latest exploit mitigations. A particular cause of concern are kernel modules given their privileged access.</p>
<p>Hexhive’s Retrowrite project is a state-of-the-art binary rewriting tool that can retrofit mitigations to legacy binaries without the need for source code. This currently works on ARM64 and x86-64 platforms, and x86-64 in kernel mode. The goal of this project would be to target ARM64 kernel modules, with the ability to add for example kASAN. We would aim to:</p>
<ul>
<li>Identify kernel modules of particular interest, including open source modules to act as ground truth.</li>
<li>Produce a framework to evaluate the effectiveness of binary rewriting these modules by exercising their functionality, using fuzzing where appropriate.</li>
<li>Modify Retrowrite to support ARM64 kernel modules.</li>
<li>Evaluate the implementation against ground truth targets and against targets of interest. Evaluate the cost of instrumentation passes.</li>
</ul>
<p>Students should have a basic understanding of how Linux kernel modules are built and loaded, and a good grasp of Linux internals. Ambitious students may also have Android Internals knowledge and be interested in testing their work on Android hardware.</p>
<h5 id="seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</h5>
<ul>
<li>Point of contact: <a href="luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Suitable for: MSc thesis</li>
<li>Keywords: kernel security, data race protection, security policy</li>
</ul>
<p>System call filtering is a crucial part of protection policies ubiquitous in cloud, desktop and mobile environments (Android, Docker, etc.). The existing SECCOMP filter system is unable to inspect arguments passed by reference since the user can modify the values in memory, resulting in a TOCTTOU exploit.</p>
<p>Midas is a novel mitigation for TOCTTOU bugs in the kernel, exploiting the user memory access API to provide double fetch protection. In this project, you will implement and evaluate SECCOMP filtering for system call arguments passed by reference, leveraging Midas to protect the kernel from the double fetch introduced in the process.</p>
<ul>
<li>This project requires:
<ul>
<li>Expert experience in C development</li>
<li>Experience with standard C/GNU build, development and debug tools (gdb, Makefiles)</li>
<li>Understanding of OS principles</li>
<li>Basic experience of OS coding/course project</li>
<li>Understanding of the x86 architecture and assembly coding/debugging</li>
</ul></li>
</ul>
<h5 id="agentic-magma-a-ground-truth-fuzzing-benchmark">Agentic Magma: A Ground-Truth Fuzzing Benchmark</h5>
<ul>
<li>Point of contact: <a href="mailto:qiang.liu@epfl.ch">Qiang Liu</a></li>
<li>Suitable for: BSc semester Project, potentially MSc semester project</li>
<li>Keywords: Agentic AI, Fuzzing, Evaluation, Benchmark</li>
</ul>
<p><a href="https://hexhive.epfl.ch/magma/">Magma</a> is a fuzzer evaluation framework that enables accurate performance measurements by leveraging ground-truth information on bugs in real software. Magma includes a library of real targets (e.g. libpng, libtiff, openssl, etc…) with real bugs that have been re-introduced into those targets based on previous bug reports and fix commits. Magma can report whether a bug is triggered, reached, or detected.</p>
<p>As time goes on, new bugs are discovered and need to be reintroduced into Magma. We aim to develop a few agentic workflows to automate this reintroduction. For this project, you are expected to:</p>
<ul>
<li>Develop agentic workflows to understand the root cause of existing bugs and generate PoCs to trigger these bugs.</li>
<li>Develop agentic workflows to understand the root cause of new bugs, patch the recent targets, and generate PoCs to trigger these bugs.</li>
</ul>
<h5 id="legacy-rebooted-a-comparative-study-of-unix-utilities-in-rust-and-c">Legacy Rebooted: A Comparative Study of Unix Utilities in Rust and C</h5>
<ul>
<li>Point of contact: <a href="mailto:rafaila.galanopoulou@epfl.ch">Rafaila Galanopoulou</a></li>
<li>Suitable for: MSc semester project or thesis, potentially also BSc semester project</li>
<li>Keywords: systems security, language safety, vulnerability analysis</li>
</ul>
<p>Developed for over 30 years, <a href="https://en.wikipedia.org/wiki/History_of_Linux">Linux</a> has already become the computing foundation for today’s digital world; from gigantic, complex mainframes (e.g., supercomputers) to cheap, wimpy embedded devices (e.g., IoTs), countless applications are built on top of it. <a href="https://doc.rust-lang.org/book/">Rust</a> is a statically and strongly-typed language. In short, its safety model regulates the accesses to memory locations: at one given time, only one variable may write to a memory location but many may read from it.</p>
<p>We focus on a selection of widely used Unix utilities such as <code>sed</code>, <code>grep</code>, <code>tar</code>, <code>find</code>, <code>netcat</code>, and <code>sort</code>. For each utility, we will either port an existing Rust-based clone or develop a minimal functional reimplementation in Rust using automated translation tools. The original GNU or BSD implementations written in C will serve as the baseline for comparison.</p>
<p>For this project, the objectives are to:</p>
<ul>
<li>Identify and compare the types and historical evolution of vulnerabilities in C and Rust implementations.</li>
<li>Analyze how Rust’s safety guarantees mitigate specific classes of bugs.</li>
<li>Evaluate the practicality and trade-offs of rewriting or porting Unix utilities from C to Rust.</li>
<li>Investigate the impact of feature set size and code complexity on the overall security surface.</li>
</ul>
<h5 id="how-deep-is-your-love">How deep is your love?</h5>
<ul>
<li>Point of contact: <a href="mailto:rafaila.galanopoulou@epfl.ch">Rafaila Galanopoulou</a></li>
<li>Suitable for: MSc semester project or thesis, potentially also BSc semester project</li>
<li>Keywords: cross-language analysis, dependency mapping, software supply chain security</li>
</ul>
<p>Modern software ecosystems increasingly rely on cross-language architectures. These dependencies are often deeply nested and opaque, making it difficult to fully understand control flow, data flow, and potential risk boundaries. Using multiple programming languages and libraries has other challenges, i.e., increasing the complexity and support issues. As a result, developers need to track versions, bugs, and compatibility with multiple compilers and runtimes rather than a single set.</p>
<p>We focus on a curated set of 10–50 real-world PyPI software projects, selected based on factors such as popularity and maturity. For each project, we will create the call graphs using either static analysis or dynamic tracing. These graphs aim to capture the complete invocation paths, including transitions between high-level code and native components written in other programming languages.</p>
<p>For this project, the objectives are to:</p>
<ul>
<li>Select and analyze a diverse set of Python projects using cross-language components.</li>
<li>Build static or dynamic call graphs that trace API and function invocations across language boundaries.</li>
<li>Annotate and classify unresolved edges, particularly those crossing into foreign code, to identify fragile or opaque integration points.</li>
<li>Visualize and quantify key metrics: total functions, call graph coverage,language breakdown, and which functionalities are implemented in each language.</li>
</ul>
<h5 id="synthesizing-peripheral-models-from-mcu-manuals-with-llms">Synthesizing Peripheral Models from MCU Manuals with LLMs</h5>
<ul>
<li>Point of contact: <a href="mailto:qinying.wang@epfl.ch">Qinying Wang</a></li>
<li>Suitable for: MSc semester project, or thesis</li>
<li>Keywords: embedded system, emulation, LLM tooling</li>
</ul>
<p>Firmware bring-up and system emulation depend on accurate peripheral models. Register maps (SVD/headers) usually exist, but side-effect semantics, including state transitions, IRQ raise/clear, cross-register dependencies, are still hand-coded from the manual’s prose. This is slow, error-prone, and hard to maintain across silicon revisions. Prior work uses fuzzing and symbolic execution [1][2] to explore register read/write patterns, but coverage of side effects and timing remains limited; some early NLP attempts [3] exist. Large Language Models (LLMs) can reliably transform semi-structured PDFs into structured specs and code when constrained by schemas, validators, and tests. We propose going further: couple LLM extraction with verification loops (e.g., counterexample-guided refinement) to turn manual text into a loadable YAML specification expressed in our vendor-agnostic description language.</p>
<p>For this project, the objectives are</p>
<ul>
<li>Create a compact LLM pipeline that ingests the MCU manual and emits our DSL YAML: (a) transcribe register tables, (b) extract side-effect rules, (c) run validators. Feed the validated rules into our existing Unicorn stub.</li>
<li>Test on one Nordic and one STM32 MCU and evaluate: (a) exact-match rate for fields/values, (b) side-effect test pass rate (state transitions, IRQs), (c) developer time saved vs. hand coding.</li>
<li>Produce a report (prompts used, checks, what failed and why, best practices). Ship the validated YAML files, the test scripts, and any small firmware demos that prove the stub runs.</li>
</ul>
<p>This project requires: interest in embedded systems, emulation, and LLM tooling; ability to read MCU manuals; Python (pipelines + Unicorn); optionally C/Rust for headers or alternative backends.</p>
<p>[1] P2IM: Scalable and hardware-independent firmware testing via automatic peripheral interface modeling. USENIX Security 20.</p>
<p>[2] Fuzzware: Using precise {MMIO} modeling for effective firmware fuzzing. USENIX Security 22.</p>
<p>[3] What your firmware tells you is not how you should emulate it: A specification-guided approach for firmware emulation. ACM CCS 2022.</p>
<h5 id="other-projects">Other projects</h5>
<p>Several other projects are possible in the areas of software and system security. We are open to discussing possible projects around the development of security benchmarks, using machine learning to detect vulnerabilities, secure memory allocation, sanitizer-based coverage tracking, and others.</p>


</div>
</section>

</main>
</body>
</html>
