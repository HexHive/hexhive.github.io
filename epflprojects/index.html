<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Mathias Payer">
<meta name="theme-color" content="#563d7c">
<title>HexHive</title>
<!-- Bootstrap core CSS -->
<link href="../css/bootstrap.min.css" rel="stylesheet"/>
<link href="../css/fontawesome.min.css" rel="stylesheet"/>
<link href="../css/academicons.min.css" rel="stylesheet"/>
</head>

<body>

<div class="container"> 
<nav class="navbar navbar-expand-md navbar-light bg-light static-top" style="background-color: #e3f2fd;">
	<a class="navbar-brand" href="../#"><img src="../img/hexhive.png" width="50px"/>&nbsp;<span style="color:#2fbf00;">Hex</span><span style="color:#000c10;">Hive</span></a>
	<div class="navbar" id="navbar">
	<ul class="navbar-nav mr-auto">
		<li><a class="nav-link" href="../#people">People</a></li>
		<li class="nav-item"><a class="nav-link" href="../publications">Publications</a></li>
		<li class="nav-item"><a class="nav-link" href="../projects">Projects</a></li>
		<li class="nav-item active"><a class="nav-link" href="#">Student Projects</a></li>
	</ul>
	</div>
	<img src="../img/epfl.png" class="ml-auto" width="100px"/>
</nav>
</div>

<main role="main" class="container">

<section id="epflprojects">
<div class="jumbotron">
<h4 id="hexhive-phd-msc-bsc-projects">HexHive PhD, MSc, BSc projects</h4>
<p>This is a list of possible open, unassigned BSc or MSc research projects in the HexHive group <b>for EPFL students</b>.</p>
<p>The projects are designed to be adjustable and scalable according to the type of BSc, MSc, or short PhD research project depending on the depth of the evaluation and exploration. For all projects we expect an open mind, good coding skills (especially in C/C++), and the willingness to learn. Previous experience with compilers (LLVM), build systems, and reverse engineering helps but is not required.</p>
<p>If you are interested in any of these topics then contact the <a href="../#people">doctoral students</a> assigned with the project. Please start your email with &quot;[(MSc|BSc) (Project|Thesis)]&quot;, e.g., &quot;[MSc Project] LLVM-based code analysis&quot;. Please explain your background such as particular coding skills or classes you took in sufficient detail, also highlight why you're interested in the project.</p>
<p>In the HexHive we welcome independent ideas from students as well, as long as they focus on the topics of system and software security, especially (but not exclusively) in sanitization of unsafe code, interactions between different components, mitigations, compiler-based security analyses, or fuzzing. So if you have an idea for your own project let us know and we can discuss! Reach out to the people most closest to your ideas and we'll let the ideas bubble up.</p>

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#library-fuzzing">Library Fuzzing</a></li>
<li><a href="#android-acropalypse">Android acropalypse</a></li>
<li><a href="#software-compartmentalization-benchmark-suite">Software Compartmentalization Benchmark suite</a></li>
<li><a href="#type-confusion-test-suite">Type confusion test suite</a></li>
<li><a href="#fuzzing-c-libraries">Fuzzing C++ libraries</a></li>
<li><a href="#arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</a></li>
<li><a href="#leveraging-application-security-through-memory-tagging">Leveraging application security through memory tagging</a></li>
<li><a href="#benchmarking-fuzzers-for-structured-text-input-software">Benchmarking Fuzzers for Structured Text Input Software</a></li>
<li><a href="#house-of-scudo">House of SCUDO</a></li>
<li><a href="#malicious-runtime-object-manipulation">Malicious Runtime Object Manipulation</a></li>
<li><a href="#augmented-regression-fuzzing">Augmented Regression Fuzzing</a></li>
<li><a href="#seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</a></li>
<li><a href="#leveraging-static-analysis-on-binaries-to-uncover-time-of-check-time-of-use-bugs">Leveraging Static Analysis on Binaries to Uncover Time-of-Check-Time-of-Use Bugs</a></li>
<li><a href="#other-projects">Other projects</a></li>
</ul>
</nav>
<h5 id="library-fuzzing">Library Fuzzing</h5>
<ul>
<li>Point of contact: <a href="mailto:flavio.toffalini@epfl.ch">Flavio Toffalini</a></li>
<li>Keywords: Linux, library, fuzzing</li>
</ul>
<p>Unlike fuzzing CLI programs, whose input is modeled as a stream of bytes, fuzzing libraries requires drivers (library consumers) to bridge an input into a sequence of APIs. The code coverage and error discovery depend on the API combinations within the driver. Therefore, it is crucial having interesting drivers to deeply test a target library. Unfortunately, building such drivers is challenging due to a lack of semantic information about the APIs and their usage. Moreover, insidious errors may appear only with rare API sequences. Current techniques infer API usage from already-existing programs, however, the quality of the new drivers is inevitably limited by the existing consumers. In this project, we aim at generating library drivers without looking into existing consumers. Precisely, we use a combination of static analysis and automatic testing to mine the API usage and automatically build drivers able to explore a vaster library portion of code and trigger more complex errors.</p>
<p>The research questions in this project are:</p>
<ul>
<li>how can we design static analysis to infer API dependency information and use them to build interesting drivers?</li>
<li>how can we use feedback from automatic testing to refine the driver generation (e.g., remove incorrect API sequences)?</li>
</ul>
<p>The candidate will require to assist the design and develop of a prototype for testing different driver building strategies. The prototype will be a combination of different technologies, such as static analysis over LLVM IR, Python modules for the driver generation, and fuzzer for the automatic testing.</p>
<p>A candidate should be interested in (or familiar with) at least one of the following topics.</p>
<ul>
<li>LLVM/Clang (also C/C++ will help)</li>
<li>Basic knowledge of static analysis</li>
<li>Python and OOP</li>
</ul>
<h5 id="android-acropalypse">Android acropalypse</h5>
<ul>
<li>Point of contact: <a href="mailto:luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Suitable for: Msc Semester Project / Thesis</li>
<li>Keywords: Reverse Engineering, Static Analysis</li>
</ul>
<p>You might have heard about the recent security disaster that is <a href="https://www.da.vidbuchanan.co.uk/blog/exploiting-acropalypse.html">aCropalypse</a>. Well, it turns out that the reason behind this bug is Google silently updating some <a href="https://issuetracker.google.com/issues/180526528?pli=1">Android’s API for opening files</a> which causes files not to be truncated anymore when opening them.</p>
<p>This is pretty wild and we think that there might be many more applications of aCropalypse, not just cropped screenshots. This project is about writing tooling to automatically analyze Android apks and searching for potential alternative data leaks.</p>
<p>A candidate should be interested in:</p>
<ul>
<li>Android application reverse engineering</li>
<li>Static analysis tooling for Android apks</li>
</ul>
<h5 id="software-compartmentalization-benchmark-suite">Software Compartmentalization Benchmark suite</h5>
<ul>
<li>Point of contact: <a href="mailto:andres.sanchez@epfl.ch">Andrés Sánchez</a></li>
<li>Keywords: compartmentalization, modularity, web applications</li>
</ul>
<p>Compartmentalization is a software-development principle to reduce a program’s attack surface, and limit the exploitability of bugs. A compartmentalized program is separated into a number of compartments, each of which executes with minimal privileges and rights, and communicates through structured API only. Essentially, an exploit in one compartment should not trivially compromise other compartments.</p>
<p>We propose a semester/thesis project for masters students, and skilled bachelors students with software development expertise in which we will compartmentalize high-risk software. Prime examples of such software are webservers, browsers and operating systems. We are open to other suggestions. We would like to eventually have a set of representative software comprising a benchmark suite against which to evaluate the different compartmentalization techniques.</p>
<p>A benchmark suite would preferably be portable, running on different operating systems/libraries, hardware, and be amenable to be ported onto hardware or software research proposals for better compartmentalization.</p>
<h5 id="type-confusion-test-suite">Type confusion test suite</h5>
<ul>
<li>Point of contact: <a href="mailto:nicolas.badoux@epfl.ch">Nicolas Badoux</a></li>
<li>Keywords: sanitizer, type confusion, test suite</li>
</ul>
<p>Type confusion is a common vulnerability in C/C++ programs. It occurs when a type is incorrectly casted to another type. This can lead to memory corruption and code execution. HexHive has published a <a href="https://nebelwelt.net/files/17CCS.pdf">number</a> of <a href="https://nebelwelt.net/files/16CCS2.pdf">works</a> trying to detect and mitigate the impact of type confusions. The goal of this project is to create a test suite for type confusion detection tools. Recent works have been evaluated on a common run time performance benchmark but they miss a validation on a common set of type confusion bugs. The test suite will be composed of a set of programs and unit test with type confusion bugs. Some bugs should be based on real world vulnerabilities while others can be purely synthetic.</p>
<p>We would aim to:</p>
<ul>
<li>Identify a set of type confusion bugs in real world programs. Create a set of</li>
<li>synthetic type confusion bugs. Create a representative set of unit tests for</li>
<li>type confusion detection tools. Evaluate state-of-the-art type confusion</li>
<li>detection tools on the test suite.</li>
</ul>
<p>Students should have a basic understanding of how C/C++ programs are built and a good grasp of Linux internals.</p>
<h5 id="fuzzing-c-libraries">Fuzzing C++ libraries</h5>
<ul>
<li>Point of contact: <a href="mailto:nicolas.badoux@epfl.ch">Nicolas Badoux</a></li>
<li>Keywords: library fuzzing, fuzzing, C++</li>
</ul>
<p>Unlike fuzzing CLI programs, whose input is modeled as a stream of bytes, fuzzing libraries requires drivers (library consumers) to bridge an input into a sequence of APIs. The code coverage and error discovery depend on the API combinations within the driver. Recent work at HexHive has shown promising result for automatically generating these drivers for C libraries. The goal of this project is to extend this work to C++ libraries. In particular, some adaptations will be necessary to handle the object-oriented nature of C++ as well as supporting casting operations.</p>
<p>The candidate will be required to identify the necessary adaptations to the existing C library fuzzing tool as well as implement support for them in the existing framework. The prototype will be a combination of different technologies, such as static analysis over LLVM IR, Python modules for the driver generation, and fuzzer for the automatic testing. The candidate will also be in charged of finding and motivating the choice of suitable C++ libraries to test.</p>
<p>A candidate should be interested in (or familiar with) the following topics.</p>
<ul>
<li>LLVM/Clang (also C/C++ will help)</li>
<li>Python</li>
</ul>
<h5 id="arm64-kernel-driver-retrowriting">ARM64 Kernel Driver Retrowriting</h5>
<ul>
<li>Point of contact: <a href="luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Keywords: Retrowrite, binary rewriting, mobile reverse engineering</li>
</ul>
<p>A common feature of the Android ecosystem are proprietary binary blobs. Vendors may not update these and may not compile them with the latest exploit mitigations. A particular cause of concern are kernel modules given their privileged access.</p>
<p>Hexhive’s Retrowrite project is a state-of-the-art binary rewriting tool that can retrofit mitigations to legacy binaries without the need for source code. This currently works on ARM64 and x86-64 platforms, and x86-64 in kernel mode. The goal of this project would be to target ARM64 kernel modules, with the ability to add for example kASAN. We would aim to:</p>
<ul>
<li>Identify kernel modules of particular interest, including open source modules to act as ground truth.</li>
<li>Produce a framework to evaluate the effectiveness of binary rewriting these modules by exercising their functionality, using fuzzing where appropriate.</li>
<li>Modify Retrowrite to support ARM64 kernel modules.</li>
<li>Evaluate the implementation against ground truth targets and against targets of interest. Evaluate the cost of instrumentation passes.</li>
</ul>
<p>Students should have a basic understanding of how Linux kernel modules are built and loaded, and a good grasp of Linux internals. Ambitious students may also have Android Internals knowledge and be interested in testing their work on Android hardware.</p>
<h5 id="leveraging-application-security-through-memory-tagging">Leveraging application security through memory tagging</h5>
<ul>
<li>Point of contact : <a href="mailto:andres.sanchez@epfl.ch">Andrés Sánchez</a></li>
<li>Keywords: Software development, virtual memory, compilers</li>
</ul>
<p>Memory tagging is a hardware extension that adds a level of restriction when dereferencing memory addresses: the key held should match the memory key. This extension can be found implemented both by Memory Protection Keys (MPK) and Memory Tagging Extension (MTE), corresponding respectively to <a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Protection.html">x86-64</a> and <a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/enhancing-memory-safety">ARM64</a> architectures, which have a different granularity (page vs 16 bytes) and way to store the key (register or per-pointer), resulting in a substantially different programming model.</p>
<p>The adoption of such a technology would be decisive for finding memory safety bugs in existing pieces of code such as <a href="https://lwn.net/Articles/643797/">databases</a>, cryptographic toolkits, operating system kernels, web servers, web browsers… Albeit this technologies are acknowledged (like MPK for which the Linux kernel provides <a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Protection.html">an interface</a>), their adoption from the application side requires a previous study which remains to be done.</p>
<p>This project includes:</p>
<ul>
<li>Acquisition of familiarity with a relevant program source code base that would benefit through memory tagging.</li>
<li>Source code modification of the codebase to include support to memory tagging.</li>
<li>Functionality testing and performance impact benchmarking</li>
<li>Potential adoption of the source code modification in the project upstream</li>
</ul>
<p>This project can be performed by either bachelor or master students, as there are different challenging codebases that can be addressed. It is also possible to do a master thesis out of it by creating a compiler-based framework that outlines in a sound way the possible protections an application can receive and analyzes them.</p>
<h5 id="benchmarking-fuzzers-for-structured-text-input-software">Benchmarking Fuzzers for Structured Text Input Software</h5>
<ul>
<li>Point of contact: <a href="mailto:chibin.zhang@epfl.ch">Chibin Zhang</a></li>
<li>Suitable for: Master Thesis Project</li>
<li>Keywords: fuzzing, benchmark, compilers, data analysis</li>
</ul>
<p>Fuzzing is an effective technique for finding bugs in software. Prior works have created benchmarks to assess the performance of fuzzers. However, these benchmarks are biased towards targets that accept binary inputs and towards fuzzers that mutate at the byte level. Additionally, they suffer from saturation, meaning the performance differences between top fuzzers are often insignificant. It is a known issue that existing byte-level fuzzers do not perform well on targets accepting structured text inputs. Current fuzzing benchmarks do not include state-of-the-art structure-aware fuzzers, such as grammar fuzzers, in their baselines. This is due to the fact that these fuzzers typically require additional grammars, dictionaries, or large seed corpora. Furthermore, existing structure-aware fuzzers have been evaluated on a limited set of disparate targets, run with different specifications, making it challenging to compare their performance quantitatively or even qualitatively.</p>
<p>In this project, you will create an extensive benchmark for targets that accept structured text inputs. You are expected to integrate at least 8 structure/syntax-aware fuzzers and 16 new targets (latest version), along with the required grammars, dictionaries, and corpora. It is suggested to use the Nix build system, as its build configurations are written declaratively and build artifacts are deterministic. This choice is anticipated to streamline the benchmarking process and ensure reproducibility. You will then conduct fuzzing campaigns and analyze the results quantitatively. A potential focus could be assessing the impact of the provided grammars, dictionaries, and corpora on the performance of the fuzzers. The build, run, and analysis scripts will be open-sourced to facilitate future research.</p>
<p>Examples of interesting fuzzers and targets for integration:</p>
<ul>
<li>Fuzzers: AFL++ with cmplog and autodict, Token-level AFL, Gramatron, Nautilus, Grimoire, Superion, Polyglot, CSmith.</li>
<li>Targets:
<ul>
<li>All targets included in fuzzbench.</li>
<li>Compilers/Interpreters/Assemblers accepting code inputs: clang, hotspot, python, php, ruby, v8, JavaScriptCore, SpiderMonkey.</li>
<li>Document formats: html, postscript, word, rtf, roff, markdown.</li>
<li>Data (interchange) formats and their processors: json, yaml, toml, xml, csv, tsv, jq, yq, sqlite.</li>
</ul></li>
</ul>
<p>Recommended Background:</p>
<ul>
<li>Completion of compiler and software security-related courses.</li>
<li>Familiarity with NixOS and Nix-based build tools.</li>
<li>Experience with fuzzing and triaging compiler/interpreter bugs.</li>
</ul>
<h5 id="house-of-scudo">House of SCUDO</h5>
<ul>
<li>Point of contact: <a href="mailto:philipp.mao@epfl.ch">Philipp Mao</a></li>
<li>Keywords: memory safety, heap, Android</li>
</ul>
<p>Since Android 11, Android has switched its memory allocator from jemalloc to scudo. This allocator has so far not been studied extensively.</p>
<p>The goal of this project is to dive deeply into the inner workings of scudo and build some exploitation “houses”. Starting from some memory corruption primitives (address leak, overflow, UAF, double free etc…) try to achieve arbitrary write/code execution. We’ll start with more powerful primitives and then subsequently try to reduce the initial primitives to build houses applicable to real-world exploitation scenarios.</p>
<p>Students interested in this project should have some experience with heap exploitation (being able to solve easy/medium heap pwn ctf challenges).</p>
<h5 id="malicious-runtime-object-manipulation">Malicious Runtime Object Manipulation</h5>
<ul>
<li>Point of contact: <a href="mailto:philipp.mao@epfl.ch">Philipp Mao</a></li>
<li>Keywords: memory safety, interpreter, cross-language attacks</li>
</ul>
<p>This project is about cross-language attacks in programs that use both interpreted and native languages.</p>
<p>The goal of this project is to study how malicious modifications of objects processed by the runtime of an interpreted language can be leveraged by an attacker. These malicious modifications take place because of a vulnerability in the part of the program written in a native language (Think an Android app written in Java that uses a vulnerable image compression library written in C). We want to investigate two attack approaches: either trying to turn the runtime that is itself written in a native language into a weird machine or changing the execution flow in the interpreted program currently being executed. For this project we will take a look at cpython or alternative python runtimes.</p>
<p>Students should have taken a course that involves writing an interpreter and have some experience with memory corruption exploitation (stack buffer overflow etc.)</p>
<h5 id="augmented-regression-fuzzing">Augmented Regression Fuzzing</h5>
<ul>
<li>Point of contact: <a href="mailto:gwangmu.lee@epfl.ch">Gwangmu Lee</a></li>
<li>Suitable for: MSc semester project, internship</li>
<li>Keywords: static analysis, fuzzing, regression bugs</li>
</ul>
<p>Recent findings suggest that new software bugs are mostly caused by patches rather than discovered in the established codebase. Meanwhile, most software bugs have definitive preconditions before being exhibited as anomalies or crashes. Some examples of preconditions include; free in use-after-free, null assignment in null-dereference, and locking in deadlock. In this project, we try to take advantage of this to augment the bug detection capability of regression fuzzing.</p>
<ul>
<li>Brief agenda
<ul>
<li>Instrumenting source code for a custom code coverage with the LLVM compiler.</li>
<li>Augmenting the regression fuzzer (AFLChurn).</li>
<li>Evaluating the augmented regression fuzzer (i.e., measuring TTE reduction and discovering new bugs)</li>
</ul></li>
<li>Preferred skills
<ul>
<li>Understanding of the LLVM IR.</li>
<li>Proficiency with understanding/modifying a C/C++ project.</li>
<li>Proficiency with command-line environments (e.g., Linux CLI).</li>
</ul></li>
</ul>
<h5 id="seccomp-implementation-for-double-fetch-protection">SECCOMP implementation for double fetch protection</h5>
<ul>
<li>Point of contact: <a href="mailto:atri.bhattacharyya@epfl.ch">Atri Bhattacharyya</a></li>
<li>Suitable for: MSc thesis</li>
<li>Keywords: kernel security, data race protection, security policy</li>
</ul>
<p>System call filtering is a crucial part of protection policies ubiquitous in cloud, desktop and mobile environments (Android, Docker, etc.). The existing SECCOMP filter system is unable to inspect arguments passed by reference since the user can modify the values in memory, resulting in a TOCTTOU exploit.</p>
<p>Midas is a novel mitigation for TOCTTOU bugs in the kernel, exploiting the user memory access API to provide double fetch protection. In this project, you will implement and evaluate SECCOMP filtering for system call arguments passed by reference, leveraging Midas to protect the kernel from the double fetch introduced in the process.</p>
<ul>
<li>This project requires:
<ul>
<li>Expert experience in C development</li>
<li>Experience with standard C/GNU build, development and debug tools (gdb, Makefiles)</li>
<li>Understanding of OS principles</li>
<li>Basic experience of OS coding/course project</li>
<li>Understanding of the x86 architecture and assembly coding/debugging</li>
</ul></li>
</ul>
<h5 id="leveraging-static-analysis-on-binaries-to-uncover-time-of-check-time-of-use-bugs">Leveraging Static Analysis on Binaries to Uncover Time-of-Check-Time-of-Use Bugs</h5>
<ul>
<li>Point of contact: <a href="mailto:marcel.busch@epfl.ch">Marcel Busch</a></li>
<li>Suitable for: MSc semester project</li>
<li>Keywords: software engineering, reverse engineering, binary analysis, static analysis</li>
</ul>
<p>TOCTOU bugs can lead to severe memory corruptions. These memory corruptions might allow adversaries to compromise and take full control of the affected system. In this project, we want to port and adapt an exisiting binary static analysis to uncover TOCTOU bugs in proprietary real-world software.</p>
<p>A candidate should be interested in (and ideally already be familiar with):</p>
<ul>
<li>Python</li>
<li>Ghidra/Ghidrathon and/or angr</li>
<li>ARM assembly</li>
<li>Static analysis (e.g., RDA)</li>
</ul>
<h5 id="other-projects">Other projects</h5>
<p>Several other projects are possible in the areas of software and system security. We are open to discuss possible projects around the development of security benchmarks, using machine learning to detect vulnerabilities, secure memory allocation, sanitizer-based coverage tracking, and others.</p>


</div>
</section>

</main>
</body>
</html>
