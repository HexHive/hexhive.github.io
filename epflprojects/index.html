<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Mathias Payer">
<meta name="theme-color" content="#563d7c">
<title>HexHive</title>
<!-- Bootstrap core CSS -->
<link href="../css/bootstrap.min.css" rel="stylesheet"/>
<link href="../css/fontawesome.min.css" rel="stylesheet"/>
<link href="../css/academicons.min.css" rel="stylesheet"/>
</head>

<body>

<div class="container"> 
<nav class="navbar navbar-expand-md navbar-light bg-light static-top" style="background-color: #e3f2fd;">
	<a class="navbar-brand" href="../#"><img src="../img/hexhive.png" width="50px"/>&nbsp;<span style="color:#2fbf00;">Hex</span><span style="color:#000c10;">Hive</span></a>
	<div class="navbar" id="navbar">
	<ul class="navbar-nav mr-auto">
		<li><a class="nav-link" href="../#people">People</a></li>
		<li class="nav-item"><a class="nav-link" href="../publications">Publications</a></li>
		<li class="nav-item active"><a class="nav-link" href="#">Projects</a></li>
	</ul>
	</div>
	<img src="../img/epfl.png" class="ml-auto" width="100px"/>
</nav>
</div>

<main role="main" class="container">

<section id="epflprojects">
<div class="jumbotron">
<h4 id="hexhive-phd-msc-bsc-projects">HexHive PhD, MSc, BSc projects</h4>
<p>This is a list of possible open, unassigned BSc or MSc research projects in the HexHive group <b>for EPFL students</b>.</p>
<p>The projects are designed to be adjustable and scalable according to the type of BSc, MSc, or short PhD research project depending on the depth of the evaluation and exploration. For all projects we expect an open mind, good coding skills (especially in C/C++), and the willingness to learn. Previous experience with compilers (LLVM), build systems, and reverse engineering helps but is not required.</p>
<p>If you are interested in any of these topics then contact the <a href="../#people">doctoral students</a> assigned with the project. Please start your email with &quot;[(MSc|BSc) (Project|Thesis)]&quot;, e.g., &quot;[MSc Project] LLVM-based code analysis&quot;. Please explain your background such as particular coding skills or classes you took in sufficient detail, also highlight why you're interested in the project.</p>
<p>In the HexHive we welcome independent ideas from students as well, as long as they focus on the topics of system and software security, especially (but not exclusively) in sanitization of unsafe code, interactions between different components, mitigations, compiler-based security analyses, or fuzzing. So if you have an idea for your own project let us know and we can discuss! Reach out to the people most closest to your ideas and we'll let the ideas bubble up.</p>

<nav id="TOC">
<ul>
<li><a href="#gui-fuzzing">GUI Fuzzing</a></li>
<li><a href="#reverse-engineering-cpu-microarchitecture">Reverse-engineering CPU microarchitecture</a></li>
<li><a href="#software-compartmentalization-benchmark-suite">Software Compartmentalization Benchmark suite</a></li>
<li><a href="#api-flow-graph-sanitization">API flow graph sanitization</a></li>
<li><a href="#incremental-fuzzing-and-sanitization">Incremental fuzzing and sanitization</a></li>
<li><a href="#secure-memory-allocator">Secure Memory Allocator</a></li>
<li><a href="#binary-vulnerability-inference">Binary vulnerability inference</a></li>
<li><a href="#information-hiding-a-new-hope">Information Hiding: A New Hope</a></li>
<li><a href="#other-projects">Other projects</a></li>
</ul>
</nav>
<h5 id="gui-fuzzing">GUI Fuzzing</h5>
<ul>
<li>Point of contact: <a href="mailto:luca.dibartolomeo@epfl.ch">Luca Di Bartolomeo</a></li>
<li>Keywords: Android, GUI, fuzzing</li>
</ul>
<p>Fuzzing has recently seen a lot of use when analyzing libraries and different CLI applications. So far, GUI applications have remained elusive due to the complexity of interactions and different entry points into the code. Especially the complex interaction patterns with the code makes fuzzing GUI applications challenging. Additionally, a driver needs to create events for the individual aspects of the application. Similarly, modern applications frequently interact with a server whose state may be unknown.</p>
<p>The key research questions in this project are:</p>
<ul>
<li>How can we design a fuzzer that handles event-based systems</li>
<li>When fuzzing event-based systems, how can the input generation keep track of fired events and interactions with the GUI app</li>
<li>If the app has a remote component, how can we model the abstract space of that component</li>
</ul>
<p>After reading into the topic of fuzzing and event-based state machines, the student will develop a model for event-based fuzzing with GUI interactions as the key part of the project. To evaluate the project, the student will then evaluate the newly generated fuzzer using a set of different GUI applications, targeting the exploration of Linux GUI apps. As a second goal, if time permits, the student will extend the exploration to apps that have remote components.</p>
<p>A candidate should be interested in (or familiar with):</p>
<ul>
<li>GUI programming</li>
<li>Android</li>
<li>C/C++ programming and event-based systems</li>
</ul>
<h5 id="reverse-engineering-cpu-microarchitecture">Reverse-engineering CPU microarchitecture</h5>
<ul>
<li>Point of contact: <a href="mailto:atri.bhattacharyya@epfl.ch">Atri Bhattacharyya</a></li>
<li>Keywords: microarchitectural attacks, side channels</li>
</ul>
<p>A number of microarchitectural side-channel attacks have emerged since 2018, of which Spectre and Meltdown surfaced in January. A critical step in all of these attacks has been a reverse-engineering effort to determine the exact behavior of components of the microarchitecture: the cache organization and replacement policy, the branch prediction algorithm and structures.</p>
<p>We would need to characterize the behavior of these components by designing experiments which target specific behavior, and can leak the structure of internal components. An example is the associativity of caches. An expt which leaks this information is the size of eviction sets. By accessing a set of memory addresses which we increase until we have cache evictions, we can figure out associativity. By modifying the access patterns, we can also infer the cache’s eviction policy. A great example on reverse engineering branch predictors on older Intel processors <a href="https://xania.org/201602/bpu-part-one">is this blog post series</a>.</p>
<p>We propose a semester project for masters students or dedicated bachelors students in which we tackle this challenge. An ideal candidate have taken a course on computer architecture and be familiar with the microarchitectural components. Experience with coding in x86 or ARM assembly will be very useful (but is not essential).</p>
<h5 id="software-compartmentalization-benchmark-suite">Software Compartmentalization Benchmark suite</h5>
<ul>
<li>Point of contact: <a href="mailto:atri.bhattacharyya@epfl.ch">Atri Bhattacharyya</a></li>
<li>Keywords: compartmentalization, modularity, web applications</li>
</ul>
<p>Compartmentalization is a software-development principle to reduce a program’s attack surface, and limit the exploitability of bugs. A compartmentalized program is separated into a number of compartments, each of which executes with minimal privileges and rights, and communicates through structured API only. Essentially, an exploit in one compartment should not trivially compromise other compartments.</p>
<p>We propose a semester/thesis project for masters students, and skilled bachelors students with software development expertise in which we will compartmentalize high-risk software. Prime examples of such software are webservers, browsers and operating systems. We are open to other suggestions. We would like to eventually have a set of representative software comprising a benchmark suite against which to evaluate the different compartmentalization techniques.</p>
<p>A benchmark suite would preferably be portable, running on different operating systems/libraries, hardware, and be amenable to be ported onto hardware or software research proposals for better compartmentalization.</p>
<h5 id="api-flow-graph-sanitization">API flow graph sanitization</h5>
<ul>
<li>Point of contact: <a href="mailto:nicolas.badoux@epfl.ch">Nicolas Badoux</a></li>
<li>Keywords: sanitizer, API graph, component analysis, compiler analysis</li>
</ul>
<p>Software components (e.g., libraries) often expose a complex API. When using a component, sequences of API calls will build up deep API state that is custom to the component. These API calls are often highly complex and dependent on each other. API call sequences for high level languages (Java) have been analyzed in software engineering but C/C++ libraries so far were neglected due to lack of type information.</p>
<p>In this project, we will build an API inference graph that, using a whole system analysis, collects all uses of a library (starting with a simple file-based search but potentially moving to a compiler-based analysis). This API graph encodes dependencies between individual API calls (e.g., read can only be called after open) and parameters for API calls (e.g., open may specify if the file can be written or not). The API graph encodes all possible API interactions and defines the parameter space for each method.</p>
<p>Based on the API graph we will then search for violations of the inferred values in real applications by implementing a sanitizer that tracks the API state and searches for violations of the valid state.</p>
<h5 id="incremental-fuzzing-and-sanitization">Incremental fuzzing and sanitization</h5>
<ul>
<li>Point of contact: <a href="mailto:nicolas.badoux@epfl.ch">Nicolas Badoux</a></li>
<li>Keywords: fuzzing, sanitization</li>
</ul>
<p>Dynamic software testing is currently an all or nothing approach. Software is compiled with sanitization and fuzzing and then evaluated. As software is developed in small steps, it would be advantageous to fuzz the delta that was added. This project will focus on developing a software testing environment that keeps track about areas that were already fuzzed or tested and which test cases had what coverage. This allows that, whenever a part of the software is changed, we can focus on that new part.</p>
<ul>
<li>Develop a mechanism to track coverage across input and sanitizer checks</li>
<li>Correlate the coverage to specific areas of software</li>
<li>Focus testing on tests that explored the changed area and see if you can focus testing on only the changed part</li>
</ul>
<p>Evaluation targets are common software repositories for open source projects.</p>
<h5 id="secure-memory-allocator">Secure Memory Allocator</h5>
<ul>
<li>Point of contact: <a href="mailto:ahmad.hazimeh@epfl.ch">Ahmad Hazimeh</a></li>
<li>Keywords: memory allocation, memory corruption, heap protection</li>
</ul>
<p>Memory allocators are primarily geared towards performance. Orthogonal to performance, memory allocators can harden a program against memory safety bugs. Use after free and other buffer overflows are common mistakes that compromise adjacent data structures on the heap. In this project we evaluate memory allocators and design a secure memory allocator alternative. The project consists of the following steps:</p>
<ul>
<li>Design a benchmark for memory allocators</li>
<li>Record allocations/deallocations and writes of benchmarks, allow replay</li>
<li>Evaluate size classes according to object sizes For the analysis of existing programs, we will check number of allocation sites, number of alloc sizes, number of alloc sizes per site. As benchmarks we will leverage SPEC CPU2017 and parallel programs.</li>
<li>Make the allocator C++ aware! (according to type classes)</li>
<li>Use classes of allocations (depending on location/type) As part of the optimization, we will discuss how to store the metadata, e.g., per thread, per allocation size, or using a mixed data structure.</li>
</ul>
<p>Discussion points for the memory allocator are: (i) if meta-data and malloc’d data is separated, (ii) (configurable) canaries between blocks, (iii) (configurable) overwrite on free, (iv) (configurable) no-reuse policy, (v) as a performance optimization: leverage guard pages and efficiently allocate them.</p>
<h5 id="binary-vulnerability-inference">Binary vulnerability inference</h5>
<ul>
<li>Point of contact: <a href="mailto:ahmad.hazimeh@epfl.ch">Ahmad Hazimeh</a></li>
<li>Keywords: binary analysis, vulnerability study, pattern-based search, measurement study</li>
</ul>
<p>Deployed programs may include third party code in inlined form or as customized libraries. Keeping these external code repositories up to date is challenging. Ideally, the program would be updated immediately with the underlying repository. Unfortunately, these updates may be forgotten. In this project, we want to study the prevalence of such misuses and forgotten updates.</p>
<ul>
<li>First, we have to detect the library version and compilation settings by developing a binary analysis that leverages features of a binary to detect its version.</li>
<li>Classify vulnerabilities and vulnerable code according to code patterns by evaluating libraries and creating a ground truth data set of code patterns and vulnerabilities.</li>
<li>Search for the classified vulnerabilities and code patterns in binaries</li>
<li>Study on packaged/prepackaged libraries and track vulnerability provenance</li>
</ul>
<p>Note that this project could also focus on Android applications.</p>
<h5 id="information-hiding-a-new-hope">Information Hiding: A New Hope</h5>
<ul>
<li>Point of contact: <a href="mailto:ahmad.hazimeh@epfl.ch">Ahmad Hazimeh</a></li>
<li>Keywords: information hiding, kernel, systems security</li>
</ul>
<p>Many mitigations require some form of meta data to check the integrity of the process and to detect violations. This defines two privilege domains with the application data and the security data. Bugs in the code that computes on application data should not be allowed to access or modify the security data. Information hiding allows low-overhead fault isolation by separating the two types of data and making it <em>unlikely</em> that the data can be accessed. As there is no actual separation, correctly guessing the address of the secure data would allow application code to overwrite secure data. Information leaks are therefore a problem, guessing oracles or allocation oracles probe for the secret area.</p>
<ul>
<li>Study existing attacks against information hiding and their weaknesses.</li>
<li>Create a kernel module and protocol that allows the allocation of safe metadata areas (the high bits on x64 are reserved to the kernel; in this vast address space we can hide some memory pages; these pages can be used to store the secure metadata). Allow allocation of memory areas in high level memory. Extend syscall of clone to allocate safe stack when creating a new thread Add syscall to allocate a new hidden memory area Add syscall to disable this feature (on per-thread basis)</li>
<li>Develop a compiler pass to move meta data to this memory area.</li>
<li>Evaluate: safe stack, OpenSSL to store keys, CFIXX, or type safety</li>
</ul>
<p>Key idea: Allocate the hidden memory areas in a safe space. High level memory reserved for kernel is the perfect place, most is unmapped and traps. The attacker cannot probe for this area.</p>
<h5 id="other-projects">Other projects</h5>
<p>Several other projects are possible in the areas of software and system security. We are open to discuss possible projects around the development of security benchmarks, using machine learning to detect vulnerabilities, secure memory allocation, sanitizer-based coverage tracking, and others.</p>


</div>
</section>

</main>
<script src="js/jquery-3.4.1.slim.min.js"></script>
<script src="js/bootstrap.bundle.min.js"></script>
</body>
</html>
