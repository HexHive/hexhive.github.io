CFIXX: Object Type Integrity for C++ Virtual

Dispatch

Nathan Burow
Purdue University
nburow@purdue.edu

Derrick McKee
Purdue University

mckee15@purdue.edu

Scott A. Carr
Purdue University
carr27@purdue.edu

Mathias Payer
Purdue University

mathias.payer@nebelwelt.net

Abstract—C++ relies on object type information for dynamic
dispatch and casting. The association of type information to an
object is implemented via the virtual table pointer, which is
stored in the object itself. C++ has neither memory nor type
safety, adversaries may therefore overwrite an object’s type. If
the corrupted type is used for dynamic dispatch, the attacker
has hijacked the application’s control ﬂow. This vulnerability
is widespread and commonly exploited. Firefox, Chrome, and
other major C++ applications are network facing, commonly
attacked, and make signiﬁcant use of dynamic dispatch. Control-
Flow Integrity (CFI) is the state of the art policy for efﬁcient
mitigation of control ﬂow hijacking attacks. CFI mechanisms
determine statically (i.e., at compile time) the set of functions
that are valid at a given call site, based on C++ semantics. We
propose an orthogonal policy, Object Type Integrity (OTI), that
dynamically tracks object types. Consequently, instead of allowing
a set of targets for each dynamic dispatch on an object, only the
single, correct target for the object’s type is allowed.

To show the efﬁcacy of OTI, we present CFIXX, which
enforces OTI. CFIXX enforces OTI by dynamically tracking
the type of each object and enforcing its integrity against
arbitrary writes. CFIXX has minimal overhead on CPU bound
applications such as SPEC CPU2006- 4.98%. On key applications
like Chromium, CFIXX has negligible overhead on JavaScript
benchmarks: 2.03% on Octane, 1.99% on Kraken, and 2.80% on
JetStream. We show that CFIXX can be deployed in conjunction
with CFI, providing a signiﬁcant security improvement.

I.

INTRODUCTION

Web browsers are among the most commonly used
and most complex applications running on today’s systems.
Browsers are responsible for correctly processing arbitrary
input in the form of web pages, including large and complex
web applications with a threat model that includes an adversary
with (restricted) code execution through JavaScript. Conse-
quently, browsers are some of the most commonly attacked
programs. The major web browsers (Firefox, Chrome, Safari,
and Internet Explorer/Edge) are written primarily in C++,
which does not enforce type safety and is prone to use after
free (UaF) and other memory safety errors. Attackers now
increasingly use type safety and UaF vulnerabilities to hijack

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’18, 18-21 February 2018, San Diego, CA, USA
Copyright 2018 Internet Society, ISBN 1-1891562-49-5
http://dx.doi.org/10.14722/ndss.2018.23xxx

the program’s control-ﬂow, frequently by redirecting dynamic
dispatch [5]. This is a form of code-reuse and indeed Return
Oriented Programming (ROP) [32], [8] attacks have been
specialized for C++ [33]. To the best of our knowledge, no
existing work fully explores how vulnerable C++’s dynamic
dispatch is to these attacks, or is capable of stopping the full
spectrum of attacks on dynamic dispatch.

C++ uses dynamic dispatch to implement polymorphism.
A key feature of polymorphism is that objects which inherit
from a base class can be up cast to that base class, while still
retaining their own implementations of any virtual methods.
Put another way, an object’s underlying type – the class it was
allocated as – determines the behavior of dynamic dispatch.
Consequently, one call site on a base class can have different
behavior depending on the type of the object at runtime.
Dynamic dispatch is used to determine which implementation
of the virtual method should be invoked. C++ relies on virtual
table pointers to implement dynamic dispatch. Virtual table
pointers tie an object to its underlying type and thus determine
the correct target for the dispatch. For dispatch, Object Type
Integrity (OTI) enforces that the correct object type is used (the
one assigned by the constructor when the object was allocated).
Dynamic dispatch leverages the virtual table pointer to identify
the type of an object, OTI therefore requires integrity of the
virtual table pointer.

Violations of OTI are possible because virtual table pointers
are fundamentally required to be in writeable memory. Each
polymorphic object (i.e., an object with virtual methods) needs
a virtual table pointer, and can exist anywhere in memory.
Consequently, the virtual table pointer has to be included in
the memory representation of the object. As C++ has neither
memory nor type safety, having virtual table pointers in the
objects exposes them to corruption. Once virtual table pointers
have been corrupted – and OTI violated – the attacker has
successfully corrupted control ﬂow information. The attacker
then forces that object
to be used for dynamic dispatch,
hijacking the control ﬂow of the program. Given control over
the program’s control ﬂow, she can mount a code reuse attack,
leading to arbitrary execution.

Observe that code reuse attacks operate in three stages: (i)
an initial memory or type safety violation, (ii) corruption of
control data, and (iii) the control ﬂow hijack [34]. The current
state-of-the art for efﬁciently mitigating code-reuse attacks
is Control-Flow Integrity (CFI) [3], [29], [37], [9], which
mitigates the third step of the attack by limiting the control
ﬂow to paths that are valid in the program’s control ﬂow
graph. CFI mechanisms specialized to deal with C++ dynamic

dispatch [37], [9] leverage the class hierarchy when computing
the set of valid targets for virtual dispatch sites, increasing
precision. Despite the precision added by class hierarchy
information, the target set can be large enough for the attacker
to ﬁnd sufﬁcient gadgets to achieve her desired goals [11],
[18], [10], [33]. Each overridden virtual function increases
imprecision, as all implementations must be in the same target
set. For large C++ applications, such as web browsers, these
sets are surprisingly large in practice, see Section III-C for
details.

CFI’s weakness – over-approximate target sets – is not
fundamental to the problem of preventing dynamic dispatch
from being used for code-reuse attacks. At runtime there is
only one correct target for any virtual call. The correct target
is dictated by the dynamic type of the object used to make
the virtual call. The alias analysis problem prevents static
analysis from determining the dynamic type of the object at
the virtual call site. Indeed, any case where static analysis can
determine the exact type, as opposed to a set of types, should
be devirtualized as an optimization. Consequently, a security
mechanism must leverage runtime information to correctly
track an object’s type and secure dynamic dispatch on that
object, as opposed to the static, compile time information that
CFI policies rely on.

i.e.,

integrity protecting it,

We propose a new defense policy, Object Type Integrity
(OTI) which guarantees that an object’s type cannot be mod-
iﬁed by an adversary,
thereby
guaranteeing the correctness of dynamic dispatch on that
object. OTI thus mitigates the second step of a code-reuse
attack by preventing key application control ﬂow data from
being corrupted. OTI tracks the assigned type for every object
at runtime. Consequently, when the object’s type is used for a
dynamic dispatch, OTI can verify that the type is uncorrupted.
Further, OTI requires that each object has a known type, thus
preventing the attacker from injecting objects [33], and using
them for dynamic dispatch. OTI distinguishes itself from CFI
by intervening one stage earlier in the attack, and by being
fully precise, instead of relying on target sets. The two can
be deployed together, as discussed in Section III-E, achieving
even greater security, as they mitigate different stages of code-
reuse attacks that utilize dynamic dispatch.

We present CFIXX, a C++ defense mechanism that ensures
the integrity of virtual table pointers, thereby enforcing OTI.
CFIXX is a practical, deployable defense that removes an
entire class of control-ﬂow hijacking targets. On Chromium,
it has negligible overhead on JavaScript benchmarks (2.03%
on Octane, 1.99% on Kraken, and 2.80% on JetStream),
unnoticeable to users. For this low cost, it guarantees that every
object used for dynamic dispatch and casts has the correct type,
removing a signiﬁcant attack surface for C++ applications.
On the CPU bound SPEC CPU2006 benchmarks, CFIXX has
4.98% overhead. This is slightly higher than the best CFI
mechanisms, which is to be expected since CFIXX intervenes
at runtime, and provides greater security. CFIXX has been used
to recompile libc++, and so protects all of user space, leaving
no vulnerabilities due to unprotected code. Further, CFIXX
shows how to efﬁciently use the new Intel Memory Protection
Extensions (MPX) to integrity protect arbitrary regions of
memory, and applies this technique to virtual table pointers.
To support further development and replication of our

2

results, our prototype OTI enforcement mechanism, CFIXX,
is open source: https://github.com/HexHive/CFIXX.

Our contributions are:

1)

2)

3)

A new defense policy, Object Type Integrity (OTI),
which mitigates all known attacks on dynamic dis-
patch.
A defense mechanism that enforces OTI, CFIXX, and
an evaluation of the prototype on SPEC CPU2006–
including libc++, and Chromium.
A demonstration of how to efﬁciently use MPX to
integrity protect arbitrary regions of memory.

II. C++ DYNAMIC DISPATCH

Dynamic dispatch is a key part of polymorphism in C++,
allowing classes to override implementations of virtual func-
tions that they inherit. Figure 1 contains a simple code exam-
ple illustrating virtual functions, overriding implementations,
and the associated memory layout. C++ implements dynamic
dispatch by maintaining a mapping from each object to its
underlying type – and thus the true implementation of the
object’s virtual functions. At each virtual call site, two things
occur: 1) the appropriate function is determined from the
object’s virtual table, and 2) an indirect call to that function is
made. The correctness of dynamic dispatch thus depends on
the integrity of the mapping from an object to its underlying
type, i.e., object type integrity.

The object type mapping at the core of dynamic dispatch is
implemented by creating a virtual table for each polymorphic
class. The virtual table consists of function pointers to the
correct implementation of each of the class’s virtual functions.
The compiler populates the virtual tables with the correct
function pointers, and is responsible for managing the virtual
function name to virtual table index mapping. The virtual
tables are ﬁxed at compile time, and mapped read only at
runtime. Each object of a class is given a virtual table pointer
which points to the virtual table for the class. Consequently,
the virtual
table assigned to an object can be thought of
as encoding the correct dynamic class of the object. An
assignment to the virtual table pointer is added by the compiler
in each of the class’s constructors.

Virtual function calls are compiled to look ups in the
object’s virtual table. The virtual table is located by using the
virtual table pointer, and the function pointer is retrieved –
recall that the compiler manages the virtual function name to
index mapping. This function pointer is then called, completing
the dispatch.

Figure 1 illustrates how this process works. Figure 1a
shows a small C++ program with two classes, Parent and
Child. Both implement a virtual function, print(), which
prints out the class name. The memory layout for an object of
each class is demonstrated in Figure 1b. Note that the virtual
table pointer is the ﬁrst ﬁeld in the object, as required by the
ABI, and is initialized by the object’s constructor. To see how
the virtual table pointer and virtual tables are used for dynamic
dispatch, consider the virtual call at line 20 in Figure 1a. The
print() function is the only virtual function, and so is at
index zero in the virtual table. To ﬁnd the correct function
pointer, indirection through the virtual table pointer is used.

1 # i n c l u d e <i o s t r e a m >
3 c l a s s P a r e n t {

p u b l i c :

i n t A = 0 ;
v i r t u a l v o i d p r i n t ( v o i d ) {
c o u t << ” P a r e n t ” << e n d l ;
}

9 } ;
11 c l a s s C h i l d : p u b l i c P a r e n t {

p u b l i c :

v o i d p r i n t ( v o i d ) o v e r r i d e {
c o u t << ” C h i l d ” << e n d l ;
}

} ;
v o i d v i r t u a l D i s p a t c h ( P a r e n t ∗p )

p−>p r i n t ( ) ;

5

7

13

15

17

23

25

27

19 {
21 }

29 }

i n t main ( v o i d ){

P a r e n t ∗p = new P a r e n t ( ) ;
C h i l d ∗c = new C h i l d ( ) ;

v i r t u a l D i s p a t c h ( p ) ;
v i r t u a l D i s p a t c h ( c ) ;

(a) C++ Polymorphic Function

(b) Memory Layout

Fig. 1: Dynamic Dispatch Illustrated.

This compiles to: p->vtp[0]() for print(). Regardless
of whether p is a Parent (line 27) or Child (line 28) object,
this lookup ﬁnds the correct implementation of print().

The description of dynamic dispatch above holds for single
inheritance. C++ allows multiple inheritance, which compli-

3

cates the implementation of dynamic dispatch, however the
same concepts hold. Multiple inheritance can result in objects
having multiple virtual tables. The ABI dictates how dynamic
dispatch handles multiple virtual tables. CFIXX handles mul-
tiple inheritance, see Section IV-B for details.

A. Constructors and Destructors

In C++, when a new object is created, a special method
known as a Constructor is called. This method initializes the
object, including assigning its virtual table pointer, or pointers
in the case of multiple inheritance. When a class is part of an
inheritance chain, the constructor for the base class is called
ﬁrst, and then the constructor for its descendant, this continues
recursively until the class of the object is reached. These
objects are all created at the same memory location, with the
result that the virtual table pointer is overwritten for each class
in the inheritance chain (for use by the intermediate class’s
constructor). Analogously, Destructors are called when an
object is destroyed. The only difference is that the inheritance
chain is traversed in the opposite order (from the object’s
destructor to the base class’s destructor). Multiple inheritance
complicates the class traversal for constructors and destructors,
the details are again ABI speciﬁc and not needed here.

III. OBJECT TYPE INTEGRITY

integrity protecting object

Object Type Integrity (OTI) is a new security policy which
focuses on C++ objects and, at its core, prevents an attacker
from changing an object’s type, or creating new, synthetic,
object types. By protecting objects’ types, OTI prevents at-
tackers from hijacking the application’s control ﬂow during
dynamic dispatch. OTI and Control Flow Integrity (CFI) thus
share a goal – mitigating control ﬂow hijacking and thus
code reuse attacks. However, OTI’s approach is orthogonal,
and complementary to, CFI policies as it intervenes earlier
in the attack,
types instead of
limiting control ﬂow transfers. Additionally, by guaranteeing
an object’s type, OTI can also protect dynamic casts, which
CFI is unable to do. To understand the security added by OTI,
we provide background on code-reuse attacks in C++, and
deﬁne both an attacker model and what is meant by control and
data attacks. With these deﬁnitions, we discuss the limitations
of CFI as a policy in securing forward control ﬂow transfers
(e.g. virtual calls), and how OTI mitigates these vulnerabilities.
In particular, OTI restricts each forward control ﬂow transfer
to one target at runtime, instead of a set of targets. As OTI and
CFI are orthogonal, they can be deployed together. We show
that using both OTI and CFI together provides signiﬁcantly
stronger security than using either in isolation.

A. Code-Reuse Attacks

Code-reuse attacks are designed to bypass deployed de-
fenses: Data Execution Prevention (DEP) [12], stack ca-
naries
[13], and Address Space Layout Randomization
(ASLR) [35], [7]. DEP prevents code injection, so code-reuse
attacks instead leverage existing executable code. Randomiza-
tion techniques such as ASLR are bypassed by leaking infor-
mation or using side-channels [17], [21]. Stack canaries [13]
prevent sequential overwrites of return addresses, but can be
bypassed by corrupting a pointer, and then using the corrupted
pointer to write to arbitrary locations.

vtable pointercpAvtable pointerA&Parent::print&Child::printHigh to LowStackHeapData......Code reuse attacks operate in three steps: (i) an initial
memory corruption, (ii) corrupting control data, and (iii) using
the corrupted value to hijack a program’s control ﬂow. As C++
enforces neither memory nor type safety, any such violation
can serve to perform the initial corruption. UaF vulnerabilities
in C++ programs are increasingly popular with attackers, and
are currently one of the most common form of memory safety
violation for C++ applications [14]. Type safety violations can
be used to attack a program’s control ﬂow through type con-
fusion attacks, e.g., CVE-2017-2095, CVE-2017-2415, CVE-
2017-5023, and Counterfeit Object Oriented Programming
(COOP) [33]. Type confusion attacks cast an object to an
illegal type where the underlying object is often of different
size. This allows the adversary to access unintended memory
and, e.g., overwrite virtual table pointers. This is typically done
through an attacker forced illegal downcast (e.g., to a sibling
class). A more advanced form of type safety violation are
COOP attacks. COOP creates (interleaved) objects that use
attacker chosen (including synthetic) virtual tables, and thus
have invalid types. COOP uses these invalidly typed objects to
achieve arbitrary execution. Both type confusion attacks and
COOP violate OTI by assigning an object a different type after
allocation, or creating a synthetic type.

C++ supports dynamic casts, which execute a runtime
check to test if the cast object is compatible with the target
type. Dynamic casts leverage C++’s Run Time Type Infor-
mation (RTTI) to verify that a cast between two classes is
valid at runtime. RTTI is associated with virtual tables in C++.
Consequently, dynamic casts rely on objects having the correct
virtual table pointer to access valid RTTI and correctly verify
the type casts. Type confusion attacks either use an object of a
different type at a static cast site or an object with a modiﬁed
vtable pointer at a dynamic cast site. In both cases a cast that
should fail completes and an object of the wrong type is used,
enabling the type confusion attack.

B. Attacker Model

We assume a strong attacker with arbitrary read and write
capabilities. The attacker cannot modify or inject code due to
DEP [12]. Her arbitrary write capability can be used to perform
control or data attacks. Control attacks are a subset of data
attacks, where the data being overwritten directly determines
control ﬂow, such as virtual table pointers. A gray area exists
between control and data attacks where data (such as this
pointers) that points to control ﬂow data is modiﬁed. Attacks
against data that points to control ﬂow data (at any level of
indirection) are in scope. Other data attacks are out of scope.
The attacker’s goal is a code-reuse attack, which requires
hijacking control ﬂow. To hijack control ﬂow, the attacker must
corrupt control data, or change the control data that is used.
There are two fundamental types of code pointers that are
writeable at run time – and thus vulnerable to corruption – in
C++ programs: (i) return address and (ii) virtual table point-
ers1. Note that backwards control ﬂow transfers (e.g., returns)
can be secured by shadows stacks or CET. These defenses
can be deployed together with OTI and CFI. Consequently,
we only consider attacks which target forward edges, meaning

1Well designed C++ programs make minimal use of C style function

pointers. VTrust found 6x more virtual calls than other indirect calls.

dynamic dispatch through virtual calls for C++ objects. There
are four avenues of attack on C++ virtual calls: modifying an
existing virtual table, injecting a new virtual table, substituting
an existing virtual table, or creating a fake object. Current
compilers map virtual tables to read only memory, preventing
attackers from modifying existing virtual tables. Injecting a
new virtual table is possible, as is substituting an existing
virtual table. The ﬁnal step of either attack is to overwrite
the virtual table pointer of an existing object with a pointer to
the attacker chosen virtual table. COOP [33] relies on creating
“fake” objects, which do not have constructors in the program’s
source, and so have no ofﬁcial type – virtual table pointer –
assigned. All three attacks center on corrupting an object’s type
via its virtual table pointer, and are included in our attacker
model.

A more subtle form of attack involves substituting one valid
object for another at a virtual call site. This is accomplished by,
e.g., over writing object pointers in memory. Such attacks that
use indirection (by modifying a pointer to a control pointer,
instead of the control pointer directly) are also considered in
our model.

C. Limitations of CFI - Web Browser Case Study

The CFI policy operates in two phases: analysis and
enforcement. At compile time, the analysis phase determines
the allowed set of targets for each virtual call site. Since this
set is determined statically, the dynamic type of the underlying
object is unknown. Consequently, the set must include, at
a minimum,
the implementation of the virtual function in
the static class of the object, and any implementation in a
descendant class that overrides it. Each such override provides
a target that an attacker can divert control ﬂow to without
violating the security policy. More coarse grained defenses
that do not leverage C++ class hierarchies rely on matching
function prototypes (with various degrees of precision), re-
sulting in even larger target sets. Function prototype analysis
is also used for C style function pointers. In principle, these
sets could be further limited by control and/or data ﬂow
analysis. The enforcement component performs a set check
at runtime, to verify that the target of the virtual call is in the
allowed set. Consequently, even though the check is performed
dynamically, it is relying on static information – the compile
time target sets – for its security properties.

To gain a sense of just how susceptible browsers are to
attacks within the minimum allowed target sets for CFI, we
quantify the size of minimum target set for virtual calls in
Chromium and Firefox. To do so, for each virtual function we
count the number of overriding methods. With this informa-
tion, and the static class of the object used, we can determine
the size of the target set at each virtual call site.

In Chromium, we found a total of 13,834 virtual
functions, nearly half of which (6,671) have more than one
implementation. Out of the 4,679 virtual functions in Firefox,
1,867 (40%) have more than one implementation. 5,828 of
the virtual calls in Chromium have more than one call site
(including
blink::ExceptionState::rethrowV8Exception
which has 1,559 call sites), and 2,188 virtual functions in
Firefox have more than one call site. Taking this data in

4

Impl Count
2
3
4
5
[6 − 9]
[10 − 19]
≥ 20
Max

Chromium

(23.57%)
(11.25%)
(5.23%)
(5.10%)
(2.52%)
(0.46%)
(0.11%)

3,260
1,556
723
705
349
63
15
78

Firefox

(22.76%)
(8.55%)
(3.06%)
(1.88%)
(2.65%)
(0.96%)
(0.04%)

1,065
400
143
88
124
45
2
107

TABLE I: Number and percent of virtual functions with
multiple implementations. Max is the maximum number of
implementations for any virtual function.

it

its totality,
is clear that modern browsers have a large
remaining exploitable surface that must be protected even
if CFI is deployed. Table I shows the number of virtual
functions in Chrome and Firefox with a given number of
implementations. The “Max” row is the maximum number
of implementations for any virtual function. Each of these
virtual functions can potentially be abused without violating
the CFI policy, highlighting the severity of the problem.

The size of the target sets represents a genuine security risk
in light of the prevalence of virtual calls. We instrumented
Chromium to count the prevalence of indirect calls through
function pointers and virtual calls. Under a normal browsing
workload, 42% of indirect calls calls were virtual. This is in
line with the results reported by VTrust [37], which found 41%
of indirect calls were virtual for Firefox. Of these indirect
but non virtual calls, over 50% are due to Chrome’s mem-
ory management wrapper. Chrome’s wrapper intercepts, e.g.,
malloc, operator new, dispatching them to its chosen
allocator, tcmalloc for Linux2.

D. OTI Policy

Object Type Integrity guarantees that each C++ object has
the correct type, e.g., virtual table pointer, and further that this
type was assigned by a valid constructor, thereby preventing
“fake” objects. Guaranteeing that every object has the correct
type in turn guarantees the correctness of C++ dynamic
dispatch and cast on the object (though not necessarily that
the correct object is used, see Section III-E). Every virtual
call or dynamic cast site has only one correct object type
at runtime, determined by the dynamic type of the object,
determined through the virtual table associated with the object.
OTI enforces that the correct virtual pointer be used for
each object during dynamic dispatch and cast, thereby ensuring
that
type – is
used. Further, in order to establish the correct type for each
object, OTI requires that every object’s type be assigned by
compiler generated code in the object’s constructor. OTI can
be thought of us a fully context and ﬂow sensitive analysis, that
takes advantage of runtime information to perfectly resolve the
correct virtual table for every object.

table – and thus object

the correct virtual

OTI mitigates all classes of attacks that can be used to
subvert forward control ﬂow transfers for any given object,
and all type confusion attacks that target dynamic casts. UaF

2See

allocator/
wrapper.

https://chromium.googlesource.com/chromium/src/base/+/master/
the implementation of Chromium’s memory management

for

5

attacks can be mitigated by invalidating an object’s virtual table
pointer when its memory is deallocated. This provides only
partial safety, as reallocating the memory can assign a new,
legitimate virtual table pointer, but it does prevent dynamic
dispatch on a free’d object before the memory is re-allocated.
Type confusion attacks, or other memory corruptions, that
attack control-ﬂow by overwriting function / virtual
table
pointers, are naturally stopped by OTI. Attacks that manu-
facture “fake” objects, such as Counterfeit Object Oriented
Programming, are prevented. These do not have recognized
types under OTI. Consequently, our check at the call site fails
due to lack of type information for the object, preventing the
attack.

Guaranteeing OTI, i.e., the integrity of virtual table point-
ers, can be used to enforce different security policies. OTI
always protects the integrity of virtual table pointers, removing
adversary access to them. The OTI policy requires that any
mechanism that implements it dispatch on the protected virtual
table pointers. By requiring dispatch on protected pointers, the
OTI policy already stops control-ﬂow hijack attacks. Imple-
mentations can extend the OTI policy by using the virtual table
pointer in attacker controllable memory as a canary. Such a
policy extension would compare the canary to the protected
virtual table pointer. If the canary and the protected pointer
are different, a policy violation is reported.

E. Combined Security of OTI and CFI

OTI distinguishes itself from CFI by utilizing runtime
information to fully protect dynamic dispatch from direct
overwrites of virtual table pointers. Such overwrites correspond
to control attacks in our attacker model. Recall, however, that
data pointers can be used indirectly to change control ﬂow by
changing, e.g., which object gets used for dynamic dispatch.
OTI on its own cannot mitigate such attacks, just as CFI on
its own cannot fully mitigate direct attacks on control data.
However, CFI can partially mitigate such indirect attacks on
control data because it creates an absolute set of valid targets,
thereby limiting the valid object substitutions that can be
made. Consequently, OTI is best used complementary with CFI
where, fully stopping attacks against code pointers earlier than
CFI and orthogonally leveraging (the potentially imprecise)
CFI target sets for any remaining attacks that modify data
pointers.

IV. DESIGN

CFIXX enforces OTI by identifying legitimate (compiler
inserted) virtual table pointer assignments. These are recorded
as the ground truth type of the objects. CFIXX then protects
the integrity of these assignments, ensuring that an attacker
cannot modify them. The integrity protection is accomplished
by recording the original virtual table pointer assignment in a
protected metadata table. Dynamic dispatch is then modiﬁed
to lookup the virtual
in our
metadata table instead of in the object itself. Dynamic casts
could be protected in the same way, but are not part of the
current prototype. CFIXX requires recompilation of the entire
program, including libraries (though a compatibility mode with
weaker security guarantees is discussed in Section VI). By
protecting all of user-space, CFIXX is guaranteed to see the
ground truth type for every legitimate object. Consequently,

table pointer for the object

dynamic dispatch on objects without metadata is detected, and
the OTI requirement that every object’s type be assigned by
compiler generated code in a constructor is enforced.

Enforcing OTI, and guaranteeing the integrity of dynamic
dispatch per object only requires protecting a small subset of
a program’s data. Dynamic dispatch only occurs for virtual
methods of polymorphic objects, meaning CFIXX only needs
to protect the virtual tables and virtual table pointers of these
objects. Virtual tables are mapped to read only memory by
current compilers. Consequently, the integrity of the virtual
table’s themselves is already guaranteed. This leaves only the
virtual table pointers in polymorphic objects that need to be
integrity protected by CFIXX.

To see how OTI secures dynamic dispatch, consider dy-
namic dispatch from an attacker’s perspective. She wants to
change the target of a virtual call, and has an arbitrary read
and write per our attacker model. She cannot modify a virtual
table, because they are mapped read only. Consequently, she
must either change a virtual table pointer in an existing object,
or create a “fake” object with a virtual table pointer of her
choice. OTI prevents her from executing either attack. She
cannot change an existing virtual table pointer, because that
would change the object’s type, violating OTI. Any object
she injects will not have a ground truth type, and thus also
violates OTI. A subtle attacker might change the object used
at a virtual call site through data-only attacks (i.e., changing
object pointers to alternate objects). The effects of such data-
only attacks can be limited through CFI.

A. Integrity for Virtual Table Pointers

Guaranteeing OTI is accomplished by protecting the in-
tegrity of virtual table pointers, which fundamentally requires
allowing only legitimate writes to virtual table pointers. De-
termining what is and is not a legitimate write is a difﬁcult
problem in general due to aliasing. However, the problem is
simpliﬁed for virtual table pointers because only constructors
can legitimately write virtual table pointers in C++. Any other
write is invalid. OTI is guaranteed if a legitimate write of a
virtual table pointer is the reaching deﬁnition at a virtual call
site. Full memory safety would accomplish this, however it is
a strictly stronger property than is required. Instead, CFIXX
guarantees that only legitimately written virtual table pointers
can be used for dynamic dispatch.

CFIXX guarantees virtual table pointer integrity through a
two part enforcement mechanism which utilizes a metadata
table: (i) recording the correct virtual table pointer in the
metadata table, and (ii) using our recorded virtual table pointer
for dynamic dispatch on the object. The metadata table is
conceptually a key-value store. The object, identiﬁed by the
this pointer serves as the key. The value stored is the correct
virtual table pointer for the object. For (i), we note that the
initial virtual table pointer assignment to the object cannot be
tampered with under DEP as it is in compiler emitted code,
and the virtual table pointer is a ﬁxed constant. Consequently,
we record the virtual table pointer assigned to the object in
our metadata table during this initial assignment. Part (ii) is
achieved by looking up the correct virtual table pointer for the
object in our metadata table during dynamic dispatch, instead
of using the – possibly attacker corrupted – virtual table pointer
in the object.

By default, our protection mechanism requires that every
object used for a virtual call has an entry in the metadata
table. If there is no metadata entry, an attack is detected
and execution is terminated. Only object’s whose constructors
CFIXX did not compile do not have metadata table entries.
CFIXX can miss constructors for three reasons: deliberately
unprotected code module (e.g., third party shared library), an
object created outside of C++ semantics (see paragraph VI-0c),
or an attacker injected object (such as “fake” objects created by
COOP). Differentiating between an object from an unprotected
module and an attacker injected object is a key challenge
for maintaining soundness while still supporting non-protected
libraries.

A “compatibility mode” that addresses the challenges of
executing with third-party libraries is described in Section VI.
CFIXX supports separate compilation and shared libraries.
Consequently, there is no technical reason to require a compat-
ibility mode. However, its availability does make it possible for
CFIXX to be incrementally deployed, hopefully encouraging
its adoption. The rest of this paper assumes that all code is
protected by CFIXX.

B. Multiple Inheritance

C++ supports multiple inheritance by allowing objects to
have multiple virtual tables. This complicates our metadata
scheme, as we can no longer use the this pointer (the pointer
to the base of the object) as our metadata key, as an object
can now require multiple metadata entries. Instead, we use the
location of each virtual table pointer in the object as the key.
Using the virtual table pointer’s address as the key allows mul-
tiple values per object in the metadata table, thereby supporting
multiple virtual tables and multiple inheritance. CFIXX is ABI
agnostic, and relies on the compiler to determine which virtual
table for a particular object should be used at a given call-site.
Once the compiler has made this decision, CFIXX uses the
integrity protected virtual table pointer corresponding to the
location in the object.

V.

IMPLEMENTATION

CFIXX is implemented on top of LLVM 3.9.1, and has
three components. The ﬁrst part is creating, and protecting,
the data structure for our metadata. Secondly, we have to
create metadata entries each time the compiler assigns a
virtual table to a polymorphic object. These compiler generated
assignments are the set of all valid writes to an object’s
virtual table pointer. Finally, we alter the dynamic dispatch
mechanism to leverage our recorded virtual table pointer for
an object, instead of the virtual table pointer contained in
the object. The current prototype of CFIXX supports 64-bit
x86 64 systems with the Itanium ABI.

A. Metadata Data Structure

Our metadata is stored in a two level lookup table, see Fig-
ure 2a. To ﬁnd the correct entry, the pointer is split into two
parts. The high order bits are the index in the top level table,
040 in the ﬁgure. Entries in the top level table are pointers to
the second level tables. The low order bits, 20 in the example,
are the index in the second level table, which stores the correct
virtual table pointer for the object.

6

(a) Logical Structure of Metadata

(b) CFIXX Metadata Memory Layout

Fig. 2: Metadata Design Illustrated. Figure 2a shows how a pointer is broken into two indexes into the top level and second
level table. The entry for the top level table points to the second level table. Figure 2b shows how all the tables are laid out in
the protected data region. The top level table is allocated ﬁrst, then all second level tables are allocated on demand.

Our decision to use a two level lookup table is based on the
allocation patterns of polymorphic objects. We found relatively
little entropy in the high order bits of object addresses, and
insufﬁcient entropy in the middle bits to justify a three level
table (see Section VII-B). Consequently, we use a two level
table, which requires one less indirection and so has better
performance without increasing the size of our metadata table.
While SPEC CPU2006 was used for our design study, the
results reﬂect that objects are either heap or stack allocated
and tend to be grouped in memory. The same metadata table
structure was used for Chromium, and is not “tuned” for
SPEC CPU2006. x86 64 uses 48 bits for virtual addresses.
Of these, we chose to use the high order 22 bits for the top
level table, and the next 23 bits for the second level tables.
All polymorphic objects are at least eight bytes large (for the
virtual table pointer), so we can disregard the low order 3 bits.
Our metadata tables are memory mapped, and large enough
for the top level table, and a ﬁxed number of second level
tables, as shown in Figure 2b. Note that mapped pages are
not touched (and thus actually allocated by the OS) until they
are needed, so we only pay the memory overhead for touched
areas of instantiated tables. Contiguously allocating the meta-
data tables allows us to only integrity protect one memory
region. The location of this region can be determined either at
runtime – allowing maximum ﬂexibility for integration with
randomization defenses such as ASLR, or at a ﬁxed location
– a performance optimization that removes an indirection on
each metadata access to lookup the table’s location.

B. Metadata Protection

Fig. 3: Address Space Rotation for MPX checks

However, this approach is comparatively easy to defeat [17],
[21]. Further, it has a performance cost because it requires an
additional redirection at runtime to ﬁnd the metadata table.
This leaves three general approaches: (i) masking, (ii) using
MPX to prevent unauthorized writes to our metadata, or
(iii) leveraging Intel’s forthcoming Memory Protection Keys
(PKEYS) to make the metadata read only except when we
need to write it (doing this via mprotect is prohibitively
expensive). Masking is well known from software-based fault
isolation and simply masks each pointer before it is being
dereferenced, e.g., through an and instruction.

Our attacker model assumes a strong attacker who can per-
form arbitrary reads and writes. Consequently, we must protect
our metadata from modiﬁcation by an adversary. The lowest
overhead option is information hiding through randomization.

The MPX hardware extension is designed to provide
hardware support for verifying that a pointer is in bounds
for memory object accesses. To do so, MPX introduces four
new 128 bit registers for storing upper and lower bounds

7

0x1000x200Virtual table pointerVirtual table pointer⋮⋮⋮⋮⋮⋮0402070x2000x100 + 0x40 + 0x20+0x000+0x0400x22 bits23 bits3 bits0x1000x200Virtual Table PointerVirtual table pointerFirst Level TableSecond Level Table #2Second Level Table #1Unallocated Second Level Table Space⋮⋮⋮⋮0x1000x200Above MetadataBelow MetadataMetadataAddress SpaceMPX Valid RangeTransformed Space(each register stores two 64 bit pointers – one for the upper
bound and one for the lower bound). Additional instructions
are provided to make bounds, load and store to the bounds
registers, and perform upper and lower bounds checks.

checks fail. MPX does not support this gracefully. However,
our rotation provides one valid region for any legal write,
which naturally ﬁts the MPX paradigm, and only requires one
bounds check.

We leverage MPX bounds checks to prevent unauthorized
writes to our metadata, by dividing memory writes into two
categories: those added by CFIXX to maintain the metadata,
and all other writes. The ﬁrst category does not require bounds
checks. For an attacker to use such writes maliciously, she
would have to have already broken CFIXX, or hijacked control
through an orthogonal attack. CFIXX adds MPX bounds
checks to the second category – all writes that do not touch
metadata. Note that reads do not need be checked as CFIXX
only requires integrity. There is no need to keep the virtual
table pointers conﬁdential. MPX checks ensure that a memory
address is within a given range. There is no way to check that
an address is not in a given range, or that either the upper
or lower bounds check passes, but not both. Consequently,
one set of bounds is needed for all non-metadata writes,
e.g, all legal memory for the writes needs to be treated as
a single, contiguous array. However, our metadata table is
mapped somewhere in the middle of the address space, leaving
a valid region both below and above our table.

CFIXX uses a novel technique to adapt MPX to perform
the required check,
illustrated in Figure 3. Our exclusive
checks are performed on a rotated version of the address space.
In our rotation, the metadata table is at the top of the address
space. This allows us to treat everything below it as the valid
range. In the rotated address space, the last valid byte of our
metadata table is at 264 − 1. Consequently, the rotation can
be accomplished by adding the appropriate offset to a given
address. Addresses that are above the metadata table in the
normal address space naturally wrap around to the bottom due
to arithmetic overﬂow. The translation is implemented as a
lea, mov, lea. The ﬁrst lea calculates the address that is
being written to, the mov loads the offset, and the second lea
applies it. Note that lea is side effect free and does not effect
the ﬂag register. CFIXX uses one MPX bounds register, with
the bounds set to 0x0 and the rotated base of our metadata
table. Consequently, after rotation CFIXX performs an MPX
upper bound check bndcu. This works because the base of
our metadata table is the upper limit of valid addresses in the
translated address space.

Our rotation offers two key advantages: (i) the protected
region can be anywhere in the address space – unlike for
masking, and (ii) it requires half as many bounds checks as a
naive MPX implementation. Masking requires the metadata
table to be at
the top of the address space. To see why,
consider what happens when high order, non-masked bits are
changed. For each combination of such bits, a hole is created
by the mask for the protected, lower order bits in the address.
Consequently, many disparate regions of memory would be
protected. Applying MPX to integrity protect a memory region
without our rotation is possible. However, MPX only provides
inclusive checks, i.e., that an address is in bounds. To provide
integrity, the opposite is desired, i.e., that a write is not in
the protected region. This is not easily accomplished, as it
requires checking if the address is in either the area below the
protected region, and if that check fails, if it is in the area above
the protected area. A violation must only be signalled if both

Intel has announced, but not yet shipped in production,
a new hardware feature called Memory Protection Keys
(PKEYS). These will allow a process to switch a page (or
group of pages) between RW and R with one register write.
This feature can naturally be used to protect our metadata.
The pages would be set R anytime CFIXX is not performing
a write to them. Since CFIXX is implemented in the compiler,
it can ensure that only authorized locations use this feature.
To maliciously use these locations, an attacker would have to
already have diverted the program’s control ﬂow. As for MPX,
this can only happen if CFIXX has already been bypassed –
rendering it irrelevant, or the attacker is utilizing an orthogonal
attack. Consequently, PKEYS can be used to protect
the
metadata. We anticipate that this will have signiﬁcantly less
overhead. Only metadata writes would be protected, instead
of all writes. Further, the protection would only require two
additional
instructions per metadata write – to toggle the
metadata to RW and back to R, instead of four instructions
per data write (three to rotate the address space, and one to
perform the bounds check). Metadata writes are dwarfed by
the number of data writes.

C. Runtime Instrumentation

With this metadata scheme in mind, the next questions
are how and when metadata is created and referenced. Recall
from Section IV that there is only one valid write of an object’s
virtual table pointer. This is when we want to create metadata
for the object. As described in Section II, virtual table pointers
are used during dynamic dispatch for virtual calls. CFIXX
instruments the virtual calls to use the virtual table pointer from
our metadata, as is illustrated with C pseudo code in Figure 4.
Figure 4a shows the C equivalent of the original code generated
by the compiler for an object constructor, and then virtual code.
Figure 4b shows the same code after CFIXX’s instrumentation.
tables are assigned to objects by the object’s
constructor. The compiler implicitly adds the virtual
table
pointer ﬁeld and writes the correct value to it in the constructor.
This holds for all constructors in C++11 (and the relevant
subset
for older versions of C++): default, programmer
speciﬁed, copy, move. Clang-3.9.1 has a common sub-routine
(CodeGenFunction::InitializeVTablePointer)
that initializes the virtual table pointer for all constructors.
CFIXX modiﬁes this sub routine to also emit instructions to
create metadata for the object. The virtual table pointer is
still written into the object as well for backward compatibility
with unprotected code and to make it possible for CFIXX to
detect and prevent attacks.

Virtual

CFIXX’s current prototype supports virtual dispatch via the

Itanium ABI. In clang-3.9.1, the Itanium ABI relies on
CodeGenFunction::GetVTablePtrCXX to retrieve the
virtual table pointer that is then used for dynamic dispatch.
CFIXX reimplements this function to read the virtual table
pointer from our metadata instead of the object. As the virtual
tables are unchanged, no further changes to dynamic dispatch
are required for it
to succeed. The detection and logging

8

t h i s . v t a b l e P o i n t e r = 0 x200 ;

/ / C o n s t r u c t o r
Foo : : Foo ( ) {
}
/ / V i r t u a l C a l l
b a r ( Foo ∗ f ){
}

f−>v t a b l e P o i n t e r [ 1 ] ( ) ;

1

3

5

7

9

2

4

6

8

10

12

14

16

/ / C o n s t r u c t o r
Foo : : Foo ( ) {

t h i s . v t a b l e P o i n t e r = 0 x200 ;
s e c o n d L e v e l = m e t a d a t a [ t h i s >>26];
i f
s e c o n d L e v e l [ ( t h i s >>3)&((1UL<<23)−1UL) ] =

s e c o n d L e v e l = a l l o c a t e 2 n d l v l ( t h i s ) ;

( s e c o n d L e v e l == NULL)

t h i s . v t a b l e P o i n t e r ;

}
/ / V i r t u a l C a l l
b a r ( Foo ∗ f ){

s e c o n d L e v e l = m e t a d a t a [ t h i s >>26];
v t a b l e P o i n t e r = s e c o n d L e v e l [ ( t h i s >>3)&((1UL<<23)−1UL) ] ;
v t a b l e P o i n t e r [ 1 ] ( ) ;

}

(a) Before CFIXX

(b) After CFIXX

Fig. 4: Virtual table pointer initialization and dynamic dispatch before and after CFIXX

modes mentioned in Section IV are simple to implement,
though not evaluated here. Implementing them requires adding
a comparison of the virtual table pointer in the object to
the virtual table pointer retrieved from memory. If they are
different, an attack would be detected, or a violation logged.
This extra if check, and potential policy action, would add
overhead, and does not affect the security provided by CFIXX,
and so was omitted here.

VI. DISCUSSION

This section elaborates on possible extensions to CFIXX
and highlights some edge cases and low level implementation
challenges such as metadata allocation, non-standard objects,
leveraging run time type information, compatibility modes, and
devirtualization.

a) Metadata Allocation: CFIXX requires its metadata
tables to be allocated before any object is allocated and has
its constructor called. The most reliable way to enforce early
metadata allocation is to add our metadata allocation function
to the .preinit-array section of the binary. This ELF
section is supported by the gold linker on both Linux and
FreeBSD (as used in our evaluation).

b) Use After Free Detection: The OTI policy can,
in principle, provide UaF protection. However, the current
CFIXX implementation does not invalidate metadata when
objects are deallocated. There are a few challenges to doing so.
First, there is no straightforward way to instrument destructors
as polymorphic objects can have trivial destructors, which
are omitted. Adding destructors would break the C++ ABI.
Consequently, we would have to instrument deallocations
directly. This means free for heap objects, and for stack
objects we would have to handle stack frame deallocation
explicitly.

c) Non-Standard Objects: It is possible to create an ob-
ject without calling its constructor. This can be accomplished
by copying an existing object with, e.g., memcpy(). Such

code violates the C++ standard3, which requires using move
or copy constructors, but does often work in practice. We found
one instance of this behavior in Chromium, see Section VII-C.
Such code should be refactored to use move or copy construc-
tors, as appropriate. CFIXX does not support objects created
in this non-standard way, requiring programmer intervention
to refactor the code. Note that such behavior is rare, we only
found one instance in total, namely in the large Chromium
code base and we refactored the code, adding three lines (a
call to our metadata create function, and a forward declaration
of that function). An alternative solution would refactor the
code to use a move constructor.

d) Run Time Type Information: RTTI is used to validate
dynamic casts at runtime. To do so, the compiler emits objects
that encapsulate an object’s type, and can be used to traverse
the type hierarchy. The RTTI objects contain virtual pointers
and are emitted at compile time. Since RTTI objects are
statically created by the compiler, no constructor is ever called
for them. To handle these objects, CFIXX adds a new function
to the ELF .ctor array that creates metadata for every RTTI
object.

e) Compatibility Mode: To support non-protected li-
braries, CFIXX can be extended to provide a compatibility
mode. In this mode, the virtual table pointer in the object’s
memory is used if we do not have a metadata entry for the
object. To secure this mode against attacker injected objects,
such as created by COOP attacks, this mode is only enabled
for virtual call sites where the static type of the object is
known to be deﬁned in a third party library. This limits COOP
attacks to creating synthetic objects from unprotected classes.
As these classes are unprotected,
the
soundness of CFIXX. Note that, if all code is protected through
CFIXX then the compatibility mode is disabled, as done for
our experiments.

this does not affect

f) Devirtualization: An important optimization for
C++ is devirtualization – replacing a virtual call with a direct

3See, e.g., section 12.8 of the C++14 standard which speciﬁes how objects

can be copied or moved.

9

call. As CFIXX changes the dynamic dispatch mechanism,
we investigated the impact on devirtualization. Currently,
enabling CFIXX causes about 10% more virtual calls in
SPEC CPU2006. We are aware of no fundamental reason
why CFIXX should prevent devirtualization and are working
on making the optimization passes in the LLVM middle-end
aware of CFIXX, so that devirtualization optimization treats
our virtual dispatch code in the same way as a regular invoke.

g) C Style Indirect Function Calls: CFIXX can be
adapted to protect C style indirect function calls. There are
two challenges: rogue function pointer writes and designing
invoke semantics for indirect function calls. First, writes to
function pointers are more difﬁcult to detect than writes of
virtual table pointers. Additionally, function pointers can be
assigned from other variables, leading to the alias analysis
problem. Consequently, possible writes of a function pointer
would have to be traced throughout the program to correctly
maintain our metadata, like SoftBound [27] did for memory
objects. Alternately, a different metadata scheme could be
used. These difﬁculties arise because we can no longer rely on
the semantics of move and copy constructors. The second chal-
lenge would be to refactor indirect function calls. Currently,
no lookup is performed. This would have to be changed so
that the correct function pointer is looked up in our metadata
and then called. Designing an efﬁcient system to address both
these challenges is left as future work.

h) Metadata Protection: There are alternatives to pro-
tecting the metadata beyond our current MPX implementation,
and the forthcoming PKEYS. An alternate MPX implementa-
tion is possible, where the metadata table is allocated at the top
of user space, eliminating the need to rotate the address space
for checks. Allocating the metadata table at the top of user
space would require moving the stack down. The principled
way to move the stack down would be to change the ﬁxed
stack start address (to which ASLR then adds randomness)
in the kernel, to guarantee that there would always be room
above the stack. Moving the stack via a kernel modiﬁcation
would have no impact on the soundness of CFIXX, and would
provide only a performance improvement. Further, it would
make CFIXX more difﬁcult to deploy. Consequently, we chose
not to implement a kernel modiﬁcation. Another alternative
to using MPX would be storing the metadata in an SGX
enclave. However, SGX provides much greater protection than
we require. Consequently, we chose not to evaluate it for
CFIXX.

VII. EVALUATION

CFIXX is evaluated along two dimensions: security and
performance. We show that CFIXX stops more attacks than
any existing control-ﬂow hijacking mitigation. On the perfor-
mance axis, we present our design study of metadata imple-
mentation alternatives, and our performance results both on
SPEC CPU2006 (4.98%) and on Chromium, using JavaScript
benchmarks (2.03% on Octane, 1.99% on Kraken, and 2.80%
on JetStream). SPEC CPU2006 was run on a machine with a
3.40 GHz Intel Core i7-6700 CPU and 16GB of RAM, under
Ubuntu 16.04. Chromium was run on a 4.0 GHz Intel Core
i7-6700K with 32GB of RAM, under FreeBSD 11.

10

Exploit Type

FakeVT

COOP

FakeVT-sig

VTxchg

VTxchg-hier

LLVM CFI

CFIXX

VTrust / VTI†



















CPS†






TABLE II: Exploits caught by vtable protection mechanisms.
VTI is Virtual Table Interleaving. See Section VII-A for expla-
nations of exploit types. † inferred from published description.

A. Exploit Coverage

We created a suite of C++ tests4 demonstrating various
possible scenarios of vtable pointer overwrites. The scenarios
we tested for are the following, listed in order of mitigation
difﬁculty:

1)

2)

3)

4)

5)

FakeVT: Inject a fake virtual table with a pointer to
a function that does not share the same signature as
the function in the original virtual table.
FakeVT-sig: Inject a fake virtual table with a pointer
to a function that shares the same function signature
(same name, number of arguments, types of argu-
ments, and order of arguments) as the function in the
original virtual table.
VTxchg: Overwrite a virtual
table pointer with a
virtual table pointer of a class outside of the original
class hierarchy (i.e., change Child’s vtable pointer
with the vtable pointer of Stranger, and Child
and Stranger are unrelated).
VTxchg-hier: Overwrite a virtual table pointer with
the virtual table pointer of a class within the same
class hierarchy (i.e., change Child1’s vtable pointer
with Child2’s and both Child1 and Child2 are
both direct children of Parent).
COOP: Create a fake object of a class (via, e.g.,
malloc) without calling the class’ constructor, and
call a virtual function of the fake object. This is the
basic COOP attack.

in virtual

the state-of-the-art

Table II summarizes the results of running the code from
our suite with LLVM CFI and CFIXX. We could not eval-
uate against
table protection,
VTrust [37] and Virtual Table Interleaving [9], because the
source was not yet made available from the authors. Based on
our analysis of the papers, we expect that VTrust and Virtual
Table Interleaving would detect 1-3. They cannot detect 4 and
5 as a valid virtual table pointer is used in the wrong context.
The VTrust paper discusses mitigating COOP, but assumes
that the control-ﬂow hijack attack violates the class hierarchy
constrained set of valid functions. This assumption does not
necessarily hold – particularly for web browsers which have
large class hierarchies, as shown in Section III-C. The latest
Code Pointer Separation [24] code was not able to compile our
code suite. However, based on the description in the paper, we
expect that CPS mitigates exploit types 1-4, but would not
protect against exploit type 5.

B. Metadata Design

An efﬁcient implementation of the metadata table is a key
component of CFIXX. The metadata table must support an
object at every (8 byte aligned) virtual address. At the same
time, CFIXX seeks to minimize memory overhead. The classic
solution to this situation is a multilevel lookup up table, e.g.,
as used for virtual memory in the page table. We initially
experimented with a three level lookup table. To examine
how program’s use memory, we logged the address of every
polymorphic object created by xalancbmk and omnetpp from
the SPEC CPU2006 benchmark suite. We then post processed
the log to determine the metadata table that would be built
under different lookup schemes.

Table III shows the results for a three level metadata table
under different conﬁgurations. Note the extremely low usage
rates for all levels. The top level (L1) only had two entries
- corresponding to the stack and the heap. The middle level
(L2) was also effectively empty. As each level of indirection
on metadata reads and writes cost performance, we eliminated
the intermediate level.

The remaining design question regards the size of the
ﬁrst and second levels in our two level lookup table. Our
experiments on this, shown in Table IV, indicate that using
the high order 22 bits is ideal. After 22 bits, density levels off
and then declines, increasing the virtual address space footprint
of our metadata.

When considering memory overhead for our scheme, it is
important to remember that we are predominantly using virtual
address space. The vast majority of the underlying pages in any
table remains untouched, and so not actually allocated by the
kernel. This minimizes our impact on physical memory usage
and performance. In the worst case, if every single memory
page of the application holds at least one virtual object, the
memory of the application doubles. In practice, we measured
a 79% increase in memory usage. It should in principle be

4Source will be available after acceptance.

L1, L2, L3
16, 16, 13
8, 16, 21
8, 8, 29

L1 #(%)

(0.00%)
(0.78%)
(0.78%)

2
2
2

L2 #(%)

2,562
14
1

(3.91%)
(0.02%)
(0.39%)

L3 #(%)
648
123,032
1,660,932

(0.99%)
(0.73%)
(0.04%)

TABLE III: Three Level Metadata Design Study. Level Sizes
are in bits. Sum is 45 – 48 used for virtual address space less
the low order 3 bits (minimum object size is 8 bytes). #(%) is
the average number of entries (density of entries). Density is
entries
2levelsize

L1, L2
18, 27
20, 25
22, 23

L1 #(%)

(0.00%)
(0.00%)
(0.00%)

2
3
8

L2 #(%)

1,660,932
1,107,288
415,233

(0.15%)
(0.41%)
(0.62%)

TABLE IV: Two Level Metadata Design Study. Level Sizes
are in bits. Sum is 45 – 48 used for virtual address space less
the low order 3 bits (minimum object size is 8 bytes). #(%) is
the average number of entries (density of entries). Density is

size

2levelsize

11

Fig. 5: SPEC CPU2006 Performance Measurements. Results
are percentage overhead. LLVM-CFI requires LTO. As a result,
the Combined measurement also uses LTO.

possible to design a more efﬁcient metadata scheme, as we
only need to store eight bytes per polymorphic object.

C. Performance

We evaluated CFIXX on the SPEC CPU2006 compiler
benchmarks, as well as on Chromium. The SPEC CPU2006
benchmarks are standard for evaluating compiler based se-
curity mechanisms, and included for comparison purposes.
Chromium is the open source version of the popular Chrome
browser. Web browsers are the most common network facing
applications, and so the usability of Chromium with CFIXX is
an important indicator of the ability of CFIXX to be deployed
in practice. For this evaluation, we used a ﬁxed metadata table
location.

Figure 5 shows the performance of the C++ benchmarks
in SPEC CPU2006 when compiled with CFIXX. CFIXX
has 2.22% overhead without MPX protecting the metadata,
and 4.98% with full MPX protection. These averages are
geometric means over the full set of benchmarks, as is
standard in the literature. LLVM includes a CFI implemen-
tation that protects virtual calls, using the same policy as
VTrust and VTable Interleaving. As VTrust and VTable In-
terleaving are not yet open source, we evaluate against the
LLVM CFI implementation. This protection is enabled with
the -fsantize=cfi-vcall ﬂag, and requires LTO. To
compare CFIXX against, we reran the baseline with LTO as
well to achieve an apples to apples comparison for measuring
the performance impact of LLVM-CFI. Despite using LTO and
a different baseline, its performance is reported in Figure 5 for
comparison. LLVM-CFI fails to run the xalancbmk benchmark,
but on the other benchmarks has 0.18% overhead, or an
average of 1.25% on benchmarks with virtual calls. This
performance is inline with the reported numbers from VTrust
and VTable Interleaving, and reinforces the fact that CFIXX
achieves almost equivalent performance with much stronger
protections.

To show that OTI and CFI are orthogonal and can work
together, we ran SPEC CPU2006 with both LLVM’s CFI
mechanism and CFIXX enabled. Only one benchmark, dealII,
that runs with LLVM-CFI failed under combined protections

 0 2 4 6 8 10 12 14444.namd447.dealII450.soplex453.povray471.omnetpp473.astar483.xalancbmkGeomeanNormalized Percentage OverheadCFIXXCFIXX-MPXLLVM-CFICOMBINED-MPX– without any additional engineering effort. We anticipate
minimal code changes will be required to make the two mech-
anisms fully compositional, and ensure that optimizations do
not mix their checks. However, running all but one benchmark
“out of the box” shows that the two are highly compatible,
and that the remaining incompatibility is an engineering issue
and not a fundamental design issue. The overhead with both
protections enabled is in line with the overhead of only OTI - a
beneﬁt of adding the LTO optimizations required by LLVM’s
CFI mechanism.

To evaluate CFIXX’s robustness and impact on real world
code, we recompiled the Chromium browser on FreeBSD.
FreeBSD was used because its ports system (i) supports clang,
and (ii) abstracts out the details of applications’ build systems.
Consequently, FreeBSD allows for more rapid prototyping of
clang-based compilers.

To benchmark Chromium, we ran the Kraken benchmark
from Mozilla, the Octane benchmark from Google, and Jet-
Stream, which is an independent benchmark. As mentioned
in paragraph VI-0c, Chromium performs a memcpy of an
allocated object. Running these benchmarks under CFIXX
required a manual code change to maintain our metadata in the
face of this non-standard code. We added three lines of code (a
call to our metadata create function, and a forward declaration
of that function) to maintain our metadata. FreeBSD does not
yet support MPX, so our evaluation of Chromium is without
MPX protection.

Browsers are benchmarked using suites of JavaScript tests.
CFIXX has the following overheads: 2.03% on Octane, 1.99%
on Kraken, and 2.80% on JetStream. The slow down is
unnoticeable to users. For this low cost, CFIXX provides
strong control-ﬂow hijacking guarantees for Chromium. By
enforcing OTI, CFIXX guarantees the correctness of dynamic
dispatch on a per object basis - something CFI policies cannot
do. As shown here, it can easily be combined with CFI to
mitigate object swapping attacks. Consequently, we believe
that CFIXX should be deployed on all browsers.

VIII. RELATED WORK

Defenses against control-ﬂow hijacking attacks have been
studied for many years. Instead of listing all proposed policies,
we will focus on control-ﬂow integrity defenses that speciﬁ-
cally target virtual dispatch and C++. We refer to a recent
survey on CFI defenses for a more complete overview [10].

VTrust [37] presented the current state of the art policy
for protecting dynamic dispatch. VTrust protects pointers to
virtual tables through a two-layered system. During runtime,
it enforces that the virtual function target matches the expected
function, as determined statically from source. VTrust ensures
that the target function name, argument type list, and class
relationship match through the use of hash signatures. The
second layer, which is optional and only needed for applica-
tions with writable code, encodes legitimate pointers to virtual
tables during object creation, and allows only such pointers to
be used. VTrust can stop COOP attacks if they cause virtual
calls to violate its computed target set, but not all COOP
attacks. VTable Interleaving [9] improves the performance of
the VTrust policy by rearranging how vtables are organized
in memory, efﬁciently packing the newly organized tables to

reduce memory overhead, and reduces virtual call dispatch
veriﬁcation to a simple range check. Neither mechanism is
open source, impeding comparative evaluation of performance
and security policies. VIP [19] builds on these policies by
adding static analysis to reduce the valid target set at virtual
call sites.

VTrust, VTable Interleaving, and VIP have less overhead
than CFIXX, but provide less security. While VIP leverages
extensive analysis of pointers to shrink target sets as much
as possible, the authors still report 1,173 call sites in Chrome
with more than 64 targets. Determining the object types that
can reach a virtual call site is a very difﬁcult problem for static
techniques, which are forced to be over-approximate or prevent
legitimate execution paths. This over-approximation limits the
security that they can provide.

PittyPat [15] performs an online analysis of execution
traces in combination with a statically computed control ﬂow
graph to determine legitimate targets of indirect control ﬂow
transfers. Consequently, PittyPat is fully path sensitive, which
makes its static analysis signiﬁcantly more precise. PittyPat
reports that 90%+ of call sites are reduced to one target.
However, a subset of call sites with a large number of targets
remains. OTI removes this remaining imprecision for C++.

πCFI [30] builds off of MCFI [29] by dynamically activat-
ing edges in the control ﬂow graph on demand. This limits the
set of targets available to attackers. However, the target set can
still grow to be the full statically computed set. Consequently,
while πCFI makes attacks more difﬁcult, it is fundamentally
no more secure than MCFI.

SafeDispatch [23] provides vtable protections against some
control ﬂow hijacking attacks, through the use of class hi-
erarchy analysis and run-time checks to conﬁrm that
the
called method is a valid implementation of the called method.
SafeDispatch incurs higher overhead (2.1% vs. 2.03% on
Octane, 1.99% on Kraken, and 2.80% on JetStream) and
cannot protect against COOP. In addition, SafeDispatch does
not support separate compilation. CFIXX supports separate
compilation, making its use in large projects practical.

VTint [36] protects against code injection attacks by pre-
venting the use of virtual tables that are writable. In legitimate
programs, objects’ virtual tables are never changed, and thus
any virtual table that is writable should never be used. VTint
checks during runtime that any used virtual table is read-only.
Recent attack classes, like COOP and vtable reuse, effectively
bypass VTint.

vfGuard [31] extracts virtual tables and call sites from
COTS binaries to determine a ﬁne-grained CFI. Once all
virtual tables and call sites are found, vfGuard then generates
a list of targets for each virtual function and enforces this CFI
policy through the use of a binary rewriter [26]. T-VIP [20] is
another example of binary rewriting that protects against code-
reuse attacks in a similar way to VTint. Again, COOP is able
to overcome these defenses. Additionally, vfGuard imposes
high overhead, making its widespread use unlikely. LLVM
provides a virtual call CFI mechanism [1]. However, as shown
in Section VII-A, CFIXX blocks more exploits with similar
runtime overhead (reported 1% vs. 2.03% on Octane, 1.99% on
Kraken, and 2.80% on JetStream on Chromium). Additionally,
LLVM CFI requires Link Time Optimization [2], which greatly

12

increases the resources needed for compilation. CFIXX does
not require Link Time Optimization.

An alternate approach to protecting application control ﬂow
is Code Pointer Integrity (CPI) and Code Pointer Separation
(CPS) [24]. CPI attempts to ensure that pointers to code (return
addresses, indirect call sites, etc.) are legitimate through the
use of instrumentation and/or runtime checks. CPS is a more
relaxed version of CPI, with lower overhead at the expense of
some safety guarantees provided by CPI. CPI experienced over
40% performance overhead on some C++ SPEC CPU2006
tests, and over 80% on pybench. CPS had lower overhead, 2%
on SPEC CPU2006. The key differences between CPS and
CFIXX are that: (i) CFIXX fully protect virtual table pointers,
whereas CPS prevents direct overwrites, but not those done
through additional indirection, and (ii) CPS cannot prevent
COOP attacks because it cannot detect synthetic objects.

Type confusion sanitizers [25], [22] also focus on protect-
ing object types. They detect static cast violations dynamically,
and do not protect dynamic dispatch. Sanitizers are orthogonal
to defenses as they focus on detecting bugs, not protecting
against adversarial attacks.

Full memory safety has been the subject of many years of
research [16], [4], [6], [28]. Mechanisms that protect unsafe
languages either incur large (> 100%) overhead, or only
provide probabilistic protections. If practical, full memory
safety would a class of vulnerabilities used by attackers to
corrupt program state, such as object types. For these reasons,
whole address space memory protection remains an ongoing
area of research.

IX. CONCLUSION

We have presented Object Type Integrity (OTI). Our new
defense policy guarantees that polymorphic objects have the
correct type associated with them at run time. By doing so, we
protect dynamic dispatch on a per object basis. OTI advances
the state of the art in protecting dynamic dispatch by limiting
objects to one target per call site, instead of a set of targets
like CFI. OTI prevents the second stage of code-reuse attacks
– corrupting control ﬂow data – whereas CFI prevents the
ﬁnal stage – control-ﬂow hijacking. Consequently, the two are
orthogonal and compatible, and can be deployed together.

Our OTI implementation, CFIXX5, has minimal overhead
on CPU bound applications such as SPEC CPU2006: 4.98%.
On key applications like Chromium, CFIXX has negligible
overhead on JavaScript benchmarks: 2.03% on Octane, 1.99%
on Kraken, and 2.80% on JetStream. CFIXX protects all code
in user space (including the libc and any shared libraries),
and comprehensively hardens dynamic dispatch. Consequently,
CFIXX is compatible with current large C++ applications such
as Chromium, readily deployable, and advances the state of the
art in protecting dynamic dispatch.

ACKNOWLEDGMENTS

We would like to thank the anonymous reviewers and
especially our shepherd Brendan Dolan-Gavitt for their in-
sightful feedback that greatly improved the ﬁnal paper. We

5The prototype implementation is open source at https://github.com/

HexHive/CFIXX.

thank Abe Clements, Bader AlBassam, James Lembke, and
Marion Marschalek for their valuable comments and discus-
sions on this paper. This material is based in part upon work
supported by the National Science Foundation under award
CNS-1513783, by ONR award N00014-17-1-2513, and by
Intel Corporation. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this material are those of
the authors and do not necessarily reﬂect the views of our
sponsors.

REFERENCES

[1]

[2]

ﬂow

“Control
ControlFlowIntegrity.html, 2016.
“Llvm
LinkTimeOptimization.html, 2017.

time

link

integrity,”

http://clang.llvm.org/docs/

optimization,”

http://llvm.org/docs/

[3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-
the 12th ACM Conference on
ser. CCS ’05. New
[Online]. Available:

ﬂow integrity,” in Proceedings of
Computer and Communications Security,
York, NY, USA: ACM, 2005, pp. 340–353.
http://doi.acm.org/10.1145/1102120.1102165

errors,”

[4] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy bounds
checking: An efﬁcient and backwards-compatible defense against
the 18th Conference
out-of-bounds
on USENIX Security Symposium, ser. SSYM’09. Berkeley, CA,
USA: USENIX Association, 2009, pp. 51–66. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1855768.1855772
I.
exception-oriented-exploitation-on-ios.html.

https://googleprojectzero.blogspot.com/2017/04/

in Proceedings of

Beer,

[5]

[6] E. D. Berger and B. G. Zorn, “Diehard: Probabilistic memory safety
for unsafe languages,” SIGPLAN Not., vol. 41, no. 6, pp. 158–168, Jun.
2006. [Online]. Available: http://doi.acm.org/10.1145/1133255.1134000
[7] S. Bhatkar, D. C. DuVarney, and R. Sekar, “Address obfuscation: An
efﬁcient approach to combat a broad range of memory error exploits.”
[8] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, “Jump-oriented
programming: a new class of code-reuse attack,” in Proceedings of the
6th ACM Symposium on Information, Computer and Communications
Security. ACM, 2011, pp. 30–40.

[9] D. Bounov, R. Kici, and S. Lerner, “Protecting c++ dynamic dispatch
through vtable interleaving,” in Annual Network and Distributed System
Security Symposium (NDSS), 2016.

[10] N. Burow, S. A. Carr, S. Brunthaler, M. Payer, J. Nash, P. Larsen, and
M. Franz, “Control-ﬂow integrity: Precision, security, and performance,”
ACM Computing Surveys (CSUR), 2018.

[11] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross,
“Control-ﬂow bending: On the effectiveness of control-ﬂow integrity,”
in Proceedings of
the 24th USENIX Conference on Security
Symposium, ser. SEC’15. Berkeley, CA, USA: USENIX Association,
2015, pp. 161–176. [Online]. Available: http://dl.acm.org/citation.cfm?
id=2831143.2831154

[12] M. Corporation, “A detailed description of the data execution prevention
(dep) feature in windows xp service pack 2, windows xp tablet pc
edition 2005, and windows server 2003,” https://support.microsoft.com/
en-us/kb/875352, 2013.

[13] C. Cowan, C. Pu, D. Maier, J. Walpole, P. Bakke, S. Beattie, A. Grier,
P. Wagle, Q. Zhang, and H. Hinton, “Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks.” in Usenix Security,
vol. 98, 1998, pp. 63–78.

[14] N. N. V. Database, https://nvd.nist.gov/.
[15] R. Ding, C. Qian, C. Song, B. Harris, T. Kim, and W. Lee, “Efﬁcient
protection of path-sensitive control security,” in 26th USENIX Security
Symposium (USENIX Security 17). Vancouver, BC: USENIX Associ-
ation, 2017, pp. 131–148. [Online]. Available: https://www.usenix.org/
conference/usenixsecurity17/technical-sessions/presentation/ding

[16] Duck, Yap, and Cavallaro, “Stack bounds protection with low fat

pointers,” in NDSS Symposium 2017, ser. NDSS 2017, 2017.

13

[17]

[18]

I. Evans, S. Fingeret, J. Gonz´alez, U. Otgonbaatar, T. Tang, H. Shrobe,
S. Sidiroglou-Douskos, M. Rinard, and H. Okhravi, “Missing the point
(er): On the effectiveness of code pointer integrity,” in Security and
Privacy (SP), 2015 IEEE Symposium on.
IEEE, 2015, pp. 781–796.
I. Evans, F. Long, U. Otgonbaatar, H. Shrobe, M. Rinard, H. Okhravi,
and S. Sidiroglou-Douskos, “Control jujutsu: On the weaknesses of ﬁne-
grained control ﬂow integrity,” in Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security. ACM, 2015,
pp. 901–913.

[19] X. Fan, Y. Sui, X. Liao, and J. Xue, “Boosting the precision of
virtual call integrity protection with partial pointer analysis for c++,” in
Proceedings of the 26th ACM SIGSOFT International Symposium on
Software Testing and Analysis. ACM, 2017, pp. 329–340.

[20] R. Gawlik and T. Holz, “Towards automated integrity protection of
c++ virtual function tables in binary programs,” in Proceedings of the
30th Annual Computer Security Applications Conference, ser. ACSAC
’14. New York, NY, USA: ACM, 2014, pp. 396–405. [Online].
Available: http://doi.acm.org/10.1145/2664243.2664249

of preventing code reuse attacks in c++ applications,” in Security and
Privacy (SP), 2015 IEEE Symposium on.
IEEE, 2015, pp. 745–762.
[34] L. Szekeres, M. Payer, T. Wei, and D. Song, “Sok: Eternal
the 2013 IEEE Symposium
war
on Security and Privacy, ser. SP ’13. Washington, DC, USA:
IEEE Computer Society, 2013, pp. 48–62.
[Online]. Available:
http://dx.doi.org/10.1109/SP.2013.13

in memory,” in Proceedings of

[35] P. Team, “Pax address space layout randomization (aslr),” 2003.
[36] C. Zhang, C. Song, K. Chen, Z. Chen, and D. Song, “Vtint: Defend-
ing virtual function tables’ integrity,” in Symposium on Network and
Distributed System Security (NDSS), 2015.

[37] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer, and D. Song,
“Vtrust: Regaining trust on virtual calls,” in Symposium on Network
and Distributed System Security (NDSS), 2016.

[22]

[21] B. Gras, K. Razavi, E. Bosman, H. Bos, and C. Giuffrida, “Aslr on the

line: Practical cache attacks on the mmu,” NDSS (Feb. 2017), 2017.
I. Haller, Y. Jeon, H. Peng, M. Payer, C. Giuffrida, H. Bos, and
E. van der Kouwe, “Typesan: Practical type confusion detection,” in
Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2016, pp. 517–528.

[23] D. Jang, Z. Tatlock, and S. Lerner, “Safedispatch: Securing c++ virtual

calls from memory corruption attacks.”

[24] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and
integrity,” in 11th USENIX Symposium
D. Song, “Code-pointer
on Operating Systems Design and Implementation (OSDI 14).
Broomﬁeld, CO: USENIX Association, Oct. 2014, pp. 147–
163.
[Online]. Available: https://www.usenix.org/conference/osdi14/
technical-sessions/presentation/kuznetsov

[25] B. Lee, C. Song, T. Kim,

casting
veriﬁcation: Stopping an emerging attack vector,” in USENIX
Security, 2015. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity15/technical-sessions/presentation/lee

and W. Lee,

“Type

[26] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V.
J. Reddi, and K. Hazelwood, “Pin: Building
customized program analysis tools with dynamic instrumentation,” in
Proceedings of the 2005 ACM SIGPLAN Conference on Programming
Language Design and Implementation,
New
York, NY, USA: ACM, 2005, pp. 190–200.
[Online]. Available:
http://doi.acm.org/10.1145/1065010.1065034

ser. PLDI

’05.

[27] S. Nagarakatte,

J. Zhao, M. M. Martin,

and S. Zdancewic,
“Softbound: Highly compatible and complete spatial memory safety
for c,” in Proceedings of the 30th ACM SIGPLAN Conference on
Programming Language Design and Implementation, ser. PLDI ’09.
New York, NY, USA: ACM, 2009, pp. 245–258. [Online]. Available:
http://doi.acm.org/10.1145/1542476.1542504

[28] ——, “Cets: Compiler enforced temporal safety for c,” in Proceedings
of the 2010 International Symposium on Memory Management, ser.
ISMM ’10. New York, NY, USA: ACM, 2010, pp. 31–40. [Online].
Available: http://doi.acm.org/10.1145/1806651.1806657

[29] B. Niu and G. Tan, “Modular control-ﬂow integrity,” in Proceedings
of the 35th ACM SIGPLAN Conference on Programming Language
Design and Implementation, ser. PLDI ’14. New York, NY, USA:
ACM, 2014, pp. 577–587. [Online]. Available: http://doi.acm.org/10.
1145/2594291.2594295

[30] ——, “Per-input control-ﬂow integrity,” in Proceedings of the 22Nd
ACM SIGSAC Conference on Computer and Communications Security,
ser. CCS ’15. New York, NY, USA: ACM, 2015, pp. 914–926.
[Online]. Available: http://doi.acm.org/10.1145/2810103.2813644

[31] A. Prakash, X. Hu, and H. Yin, “vfguard: Strict protection for virtual

function calls in cots c++ binaries.” 2015.

[32] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Transac-
tions on Information and System Security (TISSEC), vol. 15, no. 1,
p. 2, 2012.

[33] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz, “Counterfeit object-oriented programming: On the difﬁculty

14

